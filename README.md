# M√©todos N√∫mericos

## √≠ndice
+ Introducci√≥n
+ [Tema 1: Introducci√≥n a los m√©todos num√©ricos.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/blob/main/README.md#tema-1-introducci%C3%B3n-a-los-m%C3%A9todos-num%C3%A9ricos)
  - [Overflow.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/blob/main/README.md#overflow)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Redondeo.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#redondeo)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Truncamiento.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#truncamiento)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
+ [Tema 2: M√©todos de soluci√≥n de ecuaciones.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-2-m%C3%A9todos-de-soluci%C3%B3n-de-ecuaciones)
  - [Bisecci√≥n.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#bisecci%C3%B3n)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Regla falsa.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#regla-falsa)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Secante.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#secante)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
+ [Tema 3: M√©todos de soluci√≥n de sistemas de ecuaciones.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-3-m%C3%A9todos-de-soluci%C3%B3n-de-sistemas-de-ecuaciones)
  - [Eliminaci√≥n Gaussiana.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#eliminaci%C3%B3n-gaussiana)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Gauss-Jordan.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#gauss-jordan)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Gauss-Seidel.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#gauss-seidel)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Jacobi.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#jacobi)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
+ [Tema 4: Diferenciaci√≥n e integraci√≥n num√©rica.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-4-diferenciaci%C3%B3n-e-integraci%C3%B3n-num%C3%A9rica)
  - [Simpson 1/3.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#simpson-13)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Simpson 3/8.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#simpson-38)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Trapecio.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#trapecio)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
+ [Tema 5: Interpolaci√≥n y ajuste de funciones.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-5-interpolaci%C3%B3n-y-ajuste-de-funciones)
  - [Interpolaci√≥n cuadr√°tica.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#interpolaci%C3%B3n-cuadr%C3%A1tica)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Interpolaci√≥n lineal.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#interpolaci%C3%B3n-lineal)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Lagrange.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#lagrange)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Newton.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#newton)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
+ [Tema 6: Soluci√≥n de ecuaciones diferenciales.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-6-soluci%C3%B3n-de-ecuaciones-diferenciales)
  - [Euler.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#euler)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Runge-Kutta.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#runge-kutta)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.
  - [Taylor.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#taylor)
      - Definici√≥n.
      - Algoritmo.
      - C√≥digo en Java.
      - Ejercicios.

# Introducci√≥n
Los m√©todos num√©ricos son t√©cnicas matem√°ticas que permiten encontrar soluciones aproximadas a problemas complejos que no pueden resolverse de manera anal√≠tica. Estos m√©todos son fundamentales en diversas √°reas de la ingenier√≠a, la f√≠sica, la econom√≠a y otras disciplinas que requieren soluciones precisas a problemas matem√°ticos complicados. En este repositorio, exploraremos una variedad de m√©todos num√©ricos, desde los m√°s b√°sicos hasta los m√°s avanzados, implementados en el lenguaje de programaci√≥n Java.

********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 1: Introducci√≥n a los M√©todos Num√©ricos
Este primer tema proporciona una base s√≥lida sobre conceptos esenciales como el overflow, el redondeo y el truncamiento. Se define cada concepto, se explica el algoritmo correspondiente y se proporciona c√≥digo en Java junto con ejercicios pr√°cticos.
# Overflow.
## Definici√≥n
El overflow (desbordamiento) es un fen√≥meno que ocurre en los c√°lculos num√©ricos cuando un resultado excede el rango m√°ximo que puede ser representado por el tipo de dato utilizado en un sistema inform√°tico. Esto puede provocar resultados incorrectos y comportamientos inesperados en los programas.

## Algoritmo
1. Definir los l√≠mites del tipo de dato.
2. Verificar las condiciones de overflow antes de realizar la operaci√≥n.
3. Implementar la l√≥gica para lanzar una excepci√≥n o manejar el overflow si se detecta.


function safeAdd(x, y):
    if x > 0 and y > 0 and x > MAX_INT - y:
        throw OverflowException("Overflow positivo detectado")
    else if x < 0 and y < 0 and x < MIN_INT - y:
        throw OverflowException("Overflow negativo detectado")
    else:
        return x + y

function main():
    a = MAX_INT
    b = 1
    
    try:
        result = safeAdd(a, b)
        print("Resultado de la suma: " + result)
    except OverflowException as e:
        print("Overflow detectado: " + e.message)

## C√≥digo en Java

public class Overflow {
    public static void main(String[] args) {
        // Ejemplo de desbordamiento en operaciones aritm√©ticas con enteros
        int a = Integer.MAX_VALUE; // Valor m√°ximo para un entero
        int b = 1; // Incremento en 1

        // Intentamos incrementar el valor m√°ximo de un entero
        int suma = a + b;

        // Imprimimos el resultado
        System.out.println("Resultado de la suma: " + suma); // Se produce un desbordamiento
    }
}

### Salida
![Captura de pantalla (374)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/6f3ccc8e-502d-4196-b214-1b5e7ae937a9)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema1/Overflow) 

********************************************************************************************************************************************

# Redondeo.
## Definici√≥n.
El redondeo es una t√©cnica utilizada en aritm√©tica y computaci√≥n para reducir el n√∫mero de cifras significativas de un n√∫mero, ajust√°ndolo al valor m√°s cercano con una precisi√≥n especificada. Este proceso es com√∫nmente empleado para manejar la representaci√≥n de n√∫meros en sistemas digitales, donde es necesario limitar la cantidad de d√≠gitos debido a restricciones de memoria o precisi√≥n.
## Algoritmo.
1. Obtener el n√∫mero decimal a redondear.
2. Separar la parte entera y la parte fraccionaria del n√∫mero.
3. Evaluar la parte fraccionaria:
  Si la parte fraccionaria es mayor o igual a 0.5, aumentar la parte entera en 1.
  Si la parte fraccionaria es menor a 0.5, mantener la parte entera sin cambios.
4. El resultado es la parte entera ajustada seg√∫n el paso anterior.
   

function roundToNearestInteger(number):
    // Separar la parte entera y la parte fraccionaria
    integerPart = floor(number)
    fractionalPart = number - integerPart

    // Evaluar la parte fraccionaria
    if fractionalPart >= 0.5:
        return integerPart + 1
    else:
        return integerPart

function main():
    number = 3.7
    result = roundToNearestInteger(number)
    print("N√∫mero original: " + number)
    print("N√∫mero redondeado: " + result)


## C√≥digo en Java.

public class Redondeo {
    public static void main(String[] args) {
        // Ejemplo de error de redondeo en suma
        double num1 = 0.1;
        double num2 = 0.2;
        double suma = num1 + num2;

        System.out.println("Suma: " + suma); // Imprime 0.30000000000000004

        // Ejemplo de error de redondeo en multiplicaci√≥n
        double num3 = 1.0 / 3.0;
        double resultado = num3 * 3;

        System.out.println("Resultado: " + resultado); // Imprime 0.9999999999999999
    }
}

### Salida
![Captura de pantalla (375)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/f554669d-c8f3-4c87-932a-f8e4a9af4533)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema1/Redondeo)

********************************************************************************************************************************************
# Truncamiento.
## Definici√≥n.
El truncamiento es una t√©cnica utilizada en aritm√©tica y computaci√≥n para reducir el n√∫mero de cifras decimales de un n√∫mero sin redondear. Se elimina la parte fraccionaria del n√∫mero, acerc√°ndolo al valor entero m√°s cercano hacia cero. Este proceso es √∫til en situaciones donde se requiere un valor entero sin importar el valor de la parte fraccionaria.
## Algoritmo.
1. Obtener el n√∫mero decimal a truncar.
2. Separar la parte entera del n√∫mero.
3. Eliminar la parte fraccionaria del n√∫mero.
4. El resultado es la parte entera del n√∫mero.
   

function truncateNumber(number):
    // Separar la parte entera
    integerPart = floor(abs(number))

    // Restaurar el signo del n√∫mero original
    if number < 0:
        return -integerPart
    else:
        return integerPart

function main():
    number = 3.7
    result = truncateNumber(number)
    print("N√∫mero original: " + number)
    print("N√∫mero truncado: " + result)

    number = -3.7
    result = truncateNumber(number)
    print("N√∫mero original: " + number)
    print("N√∫mero truncado: " + result)

## C√≥digo en Java.

public class Truncamiento {
    public static void main(String[] args) {
        // Ejemplo de error de truncamiento en la aproximaci√≥n de una serie infinita
        int n = 10; // N√∫mero de t√©rminos a considerar en la serie
        double x = 0.5; // Valor en el que evaluamos la serie
        double suma = 0.0;

        for (int i = 0; i < n; i++) {
            suma += Math.pow(-1, i) * Math.pow(x, 2 * i + 1) / factorial(2 * i + 1);
        }

        System.out.println("Aproximaci√≥n de la serie: " + suma); // Imprime un valor aproximado
    }

    // M√©todo para calcular el factorial de un n√∫mero
    public static int factorial(int n) {
        int fact = 1;
        for (int i = 1; i <= n; i++) {
            fact *= i;
        }
        return fact;
    }
}

### Salida
![Captura de pantalla (376)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/488313b6-a23e-4347-9aae-8abcdfb1cab3)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema1/Truncamiento)
********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 2: M√©todos de Soluci√≥n de Ecuaciones
Aqu√≠ se exploran t√©cnicas para resolver ecuaciones no lineales. Los m√©todos de bisecci√≥n, regla falsa y secante se presentan con sus definiciones, algoritmos detallados, implementaciones en Java y ejercicios pr√°cticos.
# Bisecci√≥n.
## Definici√≥n.
El m√©todo de bisecci√≥n es un m√©todo num√©rico utilizado para encontrar las ra√≠ces de una funci√≥n continua. Consiste en dividir repetidamente un intervalo en dos partes y seleccionar el subintervalo en el que existe un cambio de signo de la funci√≥n, lo que indica la presencia de una ra√≠z. Este proceso se repite hasta que se alcanza un intervalo suficientemente peque√±o, proporcionando una aproximaci√≥n de la ra√≠z.
## Algoritmo.
1. Definir la funci√≥n ( f(x) ) y los extremos del intervalo ([a, b]) tal que ( f(a) \cdot f(b) < 0 ).
2. Calcular el punto medio ( c = \frac{a + b}{2} ).
3. Evaluar ( f(c) ).
Si ( f(c) = 0 ) o el intervalo es suficientemente peque√±o (criterio de convergencia), entonces ( c ) es la ra√≠z.
Si ( f(a) \cdot f(c) < 0 ), entonces la ra√≠z est√° en el intervalo ([a, c]). De lo contrario, la ra√≠z est√° en ([c, b]).
4. Repetir el proceso con el nuevo intervalo hasta que se cumpla el criterio de convergencia.


function bisection(f, a, b, epsilon):
    if f(a) * f(b) >= 0:
        throw Exception("El intervalo no contiene una ra√≠z")

    while (b - a) / 2 > epsilon:
        c = (a + b) / 2
        if f(c) == 0:
            return c // La ra√≠z exacta es encontrada
        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

    return (a + b) / 2 // Aproximaci√≥n de la ra√≠z

function main():
    // Definir la funci√≥n f(x)
    function f(x):
        return x^3 - x - 2

    // Definir el intervalo inicial [a, b] y la tolerancia epsilon
    a = 1
    b = 2
    epsilon = 0.0001

    try:
        root = bisection(f, a, b, epsilon)
        print("La ra√≠z aproximada es: " + root)
    except Exception as e:
        print(e.message)
  
## C√≥digo en Java.

/*
 * Descripcion del ejemplo

    Funci√≥n: x^3+4x^2-10    Limites: A:1 B:2    Error: 0.0001    Iteraciones: 6

    Implementacion (resultado a 5 cifras significativas)

    1.36719
 * 
 */

import java.util.Scanner;
public class Biseccion {
    public static void main(String[] args) {
        System.out.println(" EJECICIO 1 METODO DE BISECCION ");
        // Crear un objeto Scanner para leer la entrada del usuario
        Scanner scanner = new Scanner(System.in);

        System.out.print("Ingrese el l√≠mite inferior: ");
        double a = scanner.nextDouble();

        System.out.print("Ingrese el l√≠mite superior: ");
        double b = scanner.nextDouble();

        // Pedir al usuario que ingrese el n√∫mero m√°ximo de iteraciones
        System.out.print("Ingrese el n√∫mero m√°ximo de iteraciones: ");
        int maxIter = scanner.nextInt();

        // Pedir al usuario que ingrese el valor de tolerancia (error aceptable)
        System.out.print("Ingrese el valor de tolerancia: ");
        // Leer el valor de tolerancia (error aceptable) desde el usuario
        double tol = scanner.nextDouble();

        // Encontrar la ra√≠z de la funci√≥n usando el m√©todo de bisecci√≥n
        double root = bisectionMethod(a, b, maxIter, tol);

        // Imprimir el resultado
        System.out.printf("La ra√≠z de la ecuaci√≥n es: %.5f%n", root);
        /*
         Esta parte %.5f%n sirve para dejar el numero decimal con 5 digitos despues del punto decimal
        */
    }

    // Definir el m√©todo de bisecci√≥n
    public static double bisectionMethod(double a, double b, int maxIter, double tol) {
        // Verificar si la funci√≥n cambia de signo en el intervalo
        if ((func(a) * func(b)) > 0) {
            System.out.println("El m√©todo no puede encontrar una ra√≠z en el intervalo.");
            return -1;
        }

        double c;
        // repetir hasta que se alcance el n√∫mero m√°ximo de iteraciones
        for (int i = 0; i < maxIter; i++) {
            // Calcular el punto medio del intervalo
            c = (a + b) / 2;
            // Verificar si el punto medio est√° dentro de la tolerancia (error aceptable)
            if (Math.abs(func(c)) < tol) {
                // Devolver el punto medio como la ra√≠z
                return c;
            }
            // Actualizar el intervalo
            if (func(a) * func(c) < 0) {
                b = c;
            } else {
                a = c;
            }
        }
        // Devolver el punto medio del intervalo final como la ra√≠z
        return (a + b) / 2;
    }

    // Definir la funci√≥n para encontrar la ra√≠z de
    public static double func(double x) {
        return Math.pow(x, 3) + 4 * Math.pow(x, 2) - 10;
    }
}

### Salida
![Captura de pantalla (377)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/c239f15a-eaf3-4ef5-a441-d196be505e15)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema2/M%C3%A9todo%20de%20bisecci%C3%B3n)
********************************************************************************************************************************************
# Regla Falsa.
## Definici√≥n.
El m√©todo de la regla falsa, tambi√©n conocido como m√©todo de interpolaci√≥n lineal o m√©todo de la secante, es un m√©todo num√©rico para encontrar ra√≠ces de funciones continuas. A diferencia del m√©todo de bisecci√≥n, que divide el intervalo por la mitad, la regla falsa utiliza una interpolaci√≥n lineal entre los puntos finales del intervalo para estimar la ra√≠z. Este m√©todo converge m√°s r√°pidamente que el m√©todo de bisecci√≥n en ciertos casos.
## Algoritmo.
1. Definir f(x).
2. Definir los intervalos [a,b].
3. Defiinr el umbral.
4. Calcular el punto de intersecci√≥n ùëê de la l√≠nea que une (af(a) y (b,f(b)).
5. Evaluar f(c).
6. Repetir los pasos anteriores hasta que se cumpla la condici√≥n de parada.


function falsePosition(f, a, b, epsilon):
    if f(a) * f(b) >= 0:
        throw Exception("El intervalo no contiene una ra√≠z")

    while |b - a| > epsilon:
        // Calcular el punto c usando interpolaci√≥n lineal
        c = b - (f(b) * (b - a)) / (f(b) - f(a))
        
        // Evaluar f(c)
        if f(c) == 0:
            return c // La ra√≠z exacta es encontrada
        if |f(c)| < epsilon:
            return c // Aproximaci√≥n de la ra√≠z dentro de la tolerancia
        
        // Actualizar los l√≠mites del intervalo
        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

    return c // Aproximaci√≥n de la ra√≠z

function main():
    // Definir la funci√≥n f(x)
    function f(x):
        return x^3 - x - 2

    // Definir el intervalo inicial [a, b] y la tolerancia epsilon
    a = 1
    b = 2
    epsilon = 0.0001

    try:
        root = falsePosition(f, a, b, epsilon)
        print("La ra√≠z aproximada es: " + root)
    except Exception as e:
        print(e.message)


## C√≥digo en Java.

/*
 * Descripci√≥n del ejemplo

    Funci√≥n: x^4-9x^3+6  Limites: A:0  B:1    Error: 0.0001  Iteraciones: 6

    Implementaci√≥n (resultado a 5 cifras significativas)

    0.90499
 */

import java.util.Scanner;

public class ReglaFalsa {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
 
        System.out.println("EJERCICIO 1 DE METODO DE LA REGLA FALSA ");
 
        System.out.print("Ingrese el l√≠mite inferior: ");
        double a = scanner.nextDouble();
 
        System.out.print("Ingrese el l√≠mite superior: ");
        double b = scanner.nextDouble();
 
        System.out.print("Ingrese el n√∫mero m√°ximo de iteraciones: ");
        int maxIter = scanner.nextInt();
 
        System.out.print("Ingrese el valor de tolerancia: ");
        double tol = scanner.nextDouble();
 
        // Se calcula la ra√≠z de la ecuaci√≥n utilizando el m√©todo de la posici√≥n falsa
        double root = metodoReglaFalsa(a, b, maxIter, tol);
 
        // Se imprime el resultado en formato decimal con 5 cifras despu√©s del punto decimal
        System.out.printf("La ra√≠z de la ecuaci√≥n es: %.5f%n", root);
     }
 
     // M√©todo que implementa el algoritmo de la posici√≥n falsa
     public static double metodoReglaFalsa(double a, double b, int maxIter, double tol) {
        // Se verifica si la funci√≥n cambia de signo en el intervalo [a, b]
        if (func(a) * func(b) > 0) {
            System.out.println("El m√©todo no puede encontrar una ra√≠z en el intervalo.");
            return -1;
        }
        
        // Declarar las variables
        double xa, xb, xr = 0;
        xa = a;
        xb = b;
 
        for (int i = 0; i < maxIter; i++) {
            xr = xb - (func(xb) * (xb - xa) / (func(xb) - func(xa)));
            if (Math.abs(func(xr)) < tol) {
                // Si la diferencia absoluta de la funci√≥n en x2 es menor que la tolerancia, se devuelve x2 como la ra√≠z
                return xr;
            }
            if (func(xa) * func(xr) < 0) {
                // Si la funci√≥n cambia de signo entre x0 y x2, se actualiza x1
                xb = xr;
            } else {
                // De lo contrario, se actualiza x0
                xa = xr;
            }
        }
        // Si se alcanza el n√∫mero m√°ximo de iteraciones sin encontrar una ra√≠z con la tolerancia especificada, se devuelve el √∫ltimo valor de x2 como la ra√≠z aproximada
        return xr;
    }
 
     // M√©todo que define la funci√≥n cuya ra√≠z se desea encontrar
     public static double func(double x) {
        return Math.pow(x, 4) - 9 * Math.pow(x, 3) + 6;
     }
}

### Salida
![Captura de pantalla (378)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/e84fbc41-bc8b-4c7d-bb8a-9990e9016ffe)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema2/M%C3%A9todo%20de%20la%20falsa%20posici%C3%B3n)
********************************************************************************************************************************************
# Secante.
## Definici√≥n.
El m√©todo de la secante es un m√©todo num√©rico para encontrar ra√≠ces de una funci√≥n continua. Es similar al m√©todo de la regla falsa, pero en lugar de mantener un intervalo que contiene la ra√≠z, utiliza dos aproximaciones sucesivas de la ra√≠z para iterativamente acercarse a la soluci√≥n. Este m√©todo generalmente converge m√°s r√°pido que el m√©todo de bisecci√≥n y la regla falsa.
## Algoritmo.
1. Definir f(x).
2. Definir dos aproximaciones iniciales X0 y X1.
3. Definir el umbral de tolerancia.
4. Para i=1 hasta maxIter.
5. Calcular Xi+1 usando la formula.
6. Retornar Xi+1 como la ra√≠z aproximada si se ha alcanzado la tolerancia, o el valor m√°s cercano despu√©s de maxIter iteraciones.

function secant(f, x0, x1, epsilon, maxIter):
    for i from 1 to maxIter:
        // Calcular x2 usando la f√≥rmula de la secante
        x2 = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0))

        // Verificar si la diferencia es menor que la tolerancia
        if |x2 - x1| < epsilon:
            return x2 // La ra√≠z aproximada es encontrada
        
        // Actualizar las aproximaciones
        x0 = x1
        x1 = x2

    return x2 // Aproximaci√≥n de la ra√≠z despu√©s de maxIter iteraciones

function main():
    // Definir la funci√≥n f(x)
    function f(x):
        return x^3 - x - 2

    // Definir las aproximaciones iniciales x0, x1, la tolerancia epsilon y el m√°ximo de iteraciones maxIter
    x0 = 1
    x1 = 2
    epsilon = 0.0001
    maxIter = 100

    try:
        root = secant(f, x0, x1, epsilon, maxIter)
        print("La ra√≠z aproximada es: " + root)
    except Exception as e:
        print(e.message)


## C√≥digo en Java.

/*
 * Descripci√≥n del ejemplo

    Funci√≥n: x^2-3x-4  Limites: A: 3.5 B: 4.5   Error: 0.0001   Iteraciones: 6

    Implementaci√≥n (Resultado a 5 cifras decimales)

    4.00000
    4
 */
import java.util.Scanner;
public class Secante {
    public static void main(String[] args) {
        
        System.out.println(" EJEMPLO 1 METODO DE SECANTE ");
        
        Scanner scanner = new Scanner(System.in);

        System.out.print("Ingrese Xi: ");
        double x0 = scanner.nextDouble(); // Leer Xi "a"
        System.out.print("Ingrese Xi-1: ");
        double x1 = scanner.nextDouble(); // Leer Xi-1 "b"
        System.out.print("Ingrese el n√∫mero m√°ximo de iteraciones: ");
        int maxIter = scanner.nextInt(); // Leer el n√∫mero m√°ximo de iteraciones 
        System.out.print("Ingrese el valor de tolerancia: ");
        double tol = scanner.nextDouble(); // Leer el valor de tolerancia 

        double root = metodoSecante(x0, x1, maxIter, tol); // Llamar al m√©todo metodoSecante 

        System.out.printf("La ra√≠z de la ecuaci√≥n es: %.5f%n", root); // Imprimir el resultado del m√©todo metodoSecante con 5 d√≠gitos de precisi√≥n despu√©s del punto decimal
    }

    public static double metodoSecante(double x0, double x1, int maxIter, double tol) {
        if (func(x0) * func(x1) == 0) {
            System.out.println("El m√©todo no puede encontrar una ra√≠z."); // Verificar 
            return -1;
        }

        double x2 = 0;
        for (int i = 0; i < maxIter; i++) {
            x2 = x1 - (func(x1) * (x1 - x0) / (func(x1) - func(x0))); // Calcular la siguiente aproximacion usando el m√©todo de la secante
            if (Math.abs(x1 - x2) < tol) {
                return x2; // Si el cambio en las aproximaciones es menor que el valor de tolerancia, devolver la aproximacion actual como la ra√≠z
            }
            x0 = x1; // Actualizar el valor de x0
            x1 = x2; // Actualizar el valor de x1
        }
        return x2; // Si se alcanza el n√∫mero m√°ximo de iteraciones sin encontrar una ra√≠z con la tolerancia especificada, devolver la √∫ltima aproximacion
    }

    public static double func(double x) {
        return Math.pow(x, 2) - 3 * x - 4; // Definir la funci√≥n cuya ra√≠z se desea encontrar
    }
}

### Salida
![Captura de pantalla (379)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/04d5ec24-efcc-4913-8f35-7a7886dc9790)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema2/M%C3%A9todo%20de%20la%20secante)
********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 3: M√©todos de Soluci√≥n de Sistemas de Ecuaciones
Este tema aborda m√©todos para resolver sistemas de ecuaciones lineales. Se incluyen la eliminaci√≥n gaussiana, Gauss-Jordan, Gauss-Seidel y Jacobi.
# Eliminaci√≥n Gaussiana.
## Definici√≥n.
La eliminaci√≥n gaussiana es un m√©todo algebraico utilizado para resolver sistemas de ecuaciones lineales. Consiste en transformar el sistema de ecuaciones en una forma escalonada (triangular superior) utilizando operaciones elementales de fila. Una vez en esta forma, se aplica la sustituci√≥n regresiva para encontrar las soluciones del sistema.
## Algoritmo.
1. Formaci√≥n de la Matriz Aumentada: Formar la matriz aumentada del sistema de ecuaciones A|b donde A es la matriz de coeficientes y b es el vector de t√©rminos independientes.
2. ransformaci√≥n a Forma Escalonada: Para cada fila i desde 1 hasta n.
3. Pivoteo: Seleccionar el elemento con el mayor valor absoluto en la columna i de las filas i a n (pivoteo parcial) y permutar la fila actual con la fila del pivote si es necesario.
4. Eliminaci√≥n hacia adelante: Para cada fila j desde +i+1 hasta n.
5. Sustituci√≥n Regresiva: Inicializar el vector soluci√≥n x de tama√±o n.

function gaussianElimination(A, b):
    n = length(b)
    // Formar la matriz aumentada
    augmentedMatrix = augmentMatrix(A, b)

    // Transformar a forma escalonada
    for i from 1 to n:
        // Pivoteo parcial
        maxRow = i
        for k from i+1 to n:
            if abs(augmentedMatrix[k][i]) > abs(augmentedMatrix[maxRow][i]):
                maxRow = k
        swapRows(augmentedMatrix, i, maxRow)
        
        // Eliminaci√≥n hacia adelante
        for j from i+1 to n:
            m = augmentedMatrix[j][i] / augmentedMatrix[i][i]
            for k from i to n+1:
                augmentedMatrix[j][k] -= m * augmentedMatrix[i][k]

    // Sustituci√≥n regresiva
    x = new array[n]
    for i from n down to 1:
        sum = 0
        for j from i+1 to n:
            sum += augmentedMatrix[i][j] * x[j]
        x[i] = (augmentedMatrix[i][n+1] - sum) / augmentedMatrix[i][i]

    return x

function augmentMatrix(A, b):
    augmentedMatrix = new matrix[length(b)][length(b)+1]
    for i from 1 to length(b):
        for j from 1 to length(b):
            augmentedMatrix[i][j] = A[i][j]
        augmentedMatrix[i][length(b)+1] = b[i]
    return augmentedMatrix

function swapRows(matrix, row1, row2):
    temp = matrix[row1]
    matrix[row1] = matrix[row2]
    matrix[row2] = temp

function main():
    // Definir la matriz de coeficientes A y el vector de t√©rminos independientes b
    A = [
        [2, 1, -1],
        [-3, -1, 2],
        [-2, 1, 2]
    ]
    b = [8, -11, -3]

    // Resolver el sistema de ecuaciones utilizando eliminaci√≥n gaussiana
    solution = gaussianElimination(A, b)
    print("Las soluciones son: " + solution)


## C√≥digo en Java.

public class Gaussiana {
    public static void main(String[] args) {
        //paso 1 declarar matriz a resolver
        double[][] matriz = {
            {-1, 4, 2,11},
            {3, -1, 2,5},
            {2, 3, 2,12}
        };
        /*
        x=1
        y=2
        z=2
        */
        //paso 2 declarar un vector de la solucion
        double[] solucion = resolverSistema(matriz);
        //mostrar la soluci√≥n
        System.out.println("Soluci√≥n:");
        for (int i = 0; i < solucion.length; i++) {
            System.out.println("x[" + i + "] = " + solucion[i]);
        }
    }

    //metodo para resolver la matriz que retorna un vevtor de tipo double que reciba la matriz
    public static double[] resolverSistema(double[][] matriz) {
        //declaro una variable donde guarde la longitud de la matriz
        int n = matriz.length;
        //declaro un vector del tama√±o de la solucion
        double[] solucion = new double[n];
        for (int i = 0; i < n; i++) {
            // Hacer los elementos debajo de la diagonal i-√©sima igual a cero
            for (int j = i + 1; j < n; j++) {
                double factor = matriz[j][i] / matriz[i][i];
                for (int k = i; k < n + 1; k++) {
                    matriz[j][k] -= factor * matriz[i][k];
                }
            }
        }
        // Sustituci√≥n hacia atr√°s
        for (int i = n - 1; i >= 0; i--) {
            solucion[i] = matriz[i][n] / matriz[i][i];
            for (int j = i - 1; j >= 0; j--) {
                matriz[j][n] -= matriz[j][i] * solucion[i];
            }
        }

        return solucion;
    }
}

### Salida
![Captura de pantalla (380)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/30aad72a-190a-40b5-b2bb-2829909e8409)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema3/Eliminaci%C3%B3n%20Gaussiana)
********************************************************************************************************************************************
# Gauss-Jordan.
## Definici√≥n.
El m√©todo de Gauss-Jordan es una extensi√≥n del m√©todo de eliminaci√≥n gaussiana que transforma una matriz en su forma reducida por filas (forma escalonada reducida). Este m√©todo no solo convierte la matriz en una forma triangular superior, sino que tambi√©n elimina todos los coeficientes por debajo y por encima de los pivotes, resultando en una matriz identidad en el lado izquierdo de la matriz aumentada.
## Algoritmo.
1. Definir la matriz de coeficientes ( A ) y el vector de t√©rminos independientes ( b ).
2. Construir la matriz aumentada ([A | b]).
3. Aplicar las operaciones de fila para transformar la matriz aumentada en la forma ([I | x]), donde ( I ) es la matriz identidad.
4. El vector resultante en la columna de t√©rminos independientes es la soluci√≥n ( x ).

function gaussJordan(A, b):
    n = length(b)
    // Formar la matriz aumentada
    augmentedMatrix = augmentMatrix(A, b)

    // Transformar a forma escalonada reducida
    for i from 1 to n:
        // Pivoteo parcial
        maxRow = i
        for k from i+1 to n:
            if abs(augmentedMatrix[k][i]) > abs(augmentedMatrix[maxRow][i]):
                maxRow = k
        swapRows(augmentedMatrix, i, maxRow)
        
        // Normalizaci√≥n
        pivot = augmentedMatrix[i][i]
        for k from i to n+1:
            augmentedMatrix[i][k] /= pivot

        // Eliminaci√≥n
        for j from 1 to n:
            if j != i:
                factor = augmentedMatrix[j][i]
                for k from i to n+1:
                    augmentedMatrix[j][k] -= factor * augmentedMatrix[i][k]

    // Extraer soluciones
    x = new array[n]
    for i from 1 to n:
        x[i] = augmentedMatrix[i][n+1]

    return x

function augmentMatrix(A, b):
    augmentedMatrix = new matrix[length(b)][length(b)+1]
    for i from 1 to length(b):
        for j from 1 to length(b):
            augmentedMatrix[i][j] = A[i][j]
        augmentedMatrix[i][length(b)+1] = b[i]
    return augmentedMatrix

function swapRows(matrix, row1, row2):
    temp = matrix[row1]
    matrix[row1] = matrix[row2]
    matrix[row2] = temp

function main():
    // Definir la matriz de coeficientes A y el vector de t√©rminos independientes b
    A = [
        [2, 1, -1],
        [-3, -1, 2],
        [-2, 1, 2]
    ]
    b = [8, -11, -3]

    // Resolver el sistema de ecuaciones utilizando Gauss-Jordan
    solution = gaussJordan(A, b)
    print("Las soluciones son: " + solution)


## C√≥digo en Java.

public class GaussJordan {
    public static void main(String[] args) {
        double[][] matriz = {
            {2, 1, -1, 8},
            {-3, -1, 2, -11},
            {-2, 1, 2, -3}
        };
        /*
        x1 = 2.0
        x2 = 3.0
        x3 = -1.0
        */
        double[] solucion = resolverSistema(matriz);
        
        System.out.println("Soluci√≥n:");
        for (int i = 0; i < solucion.length; i++) {
            System.out.println("x[" + i + "] = " + solucion[i]);
        }
    }
    
    public static double[] resolverSistema(double[][] matriz) {
        int n = matriz.length;
        double[] solucion = new double[n];
        
        // Convertir la matriz a una forma escalonada reducida por filas (forma escalonada reducida por Gauss-Jordan)
        for (int i = 0; i < n; i++) {
            // Dividir la fila i-√©sima para que el elemento diagonal sea igual a 1
            double divisor = matriz[i][i];
            for (int j = i; j < n + 1; j++) {
                matriz[i][j] /= divisor;
            }
            
            // Hacer cero los elementos por encima y por debajo del elemento diagonal
            for (int k = 0; k < n; k++) {
                if (k != i) {
                    double factor = matriz[k][i];
                    for (int j = i; j < n + 1; j++) {
                        matriz[k][j] -= factor * matriz[i][j];
                    }
                }
            }
        }
        
        // Extraer la soluci√≥n del sistema de ecuaciones de la √∫ltima columna
        for (int i = 0; i < n; i++) {
            solucion[i] = matriz[i][n];
        }
        
        return solucion;
    }
}

### Salida
![Captura de pantalla (382)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/5c35c2f9-46ba-44e4-babb-a33336334423)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema3/M%C3%A9todo%20de%20Gauss-Jordan)
********************************************************************************************************************************************
# Gauss-Seidel.
## Definici√≥n.
El m√©todo de Gauss-Seidel es un m√©todo iterativo utilizado para resolver sistemas de ecuaciones lineales. A diferencia de los m√©todos directos como la eliminaci√≥n gaussiana, los m√©todos iterativos generan una sucesi√≥n de aproximaciones que convergen a la soluci√≥n exacta. El m√©todo de Gauss-Seidel mejora cada componente de la soluci√≥n secuencialmente y utiliza inmediatamente las aproximaciones m√°s recientes disponibles.
## Algoritmo.
1. Inicializar las soluciones (x_0^{(0)}, x_1^{(0)}, ..., x_n^{(0)}) de manera arbitraria o utilizando valores aproximados.
2. Para cada ecuaci√≥n (i) en el sistema, calcular (x_i^{(k+1)}) utilizando las soluciones calculadas en la iteraci√≥n (k).
3. Repetir el paso 2 hasta que se satisfaga un criterio de convergencia (por ejemplo, la diferencia entre dos iteraciones consecutivas sea menor que una tolerancia predefinida).
   

function gaussSeidel(A, b, x0, epsilon, maxIter):
    n = length(b)
    x = copy(x0)

    for k from 1 to maxIter:
        x_old = copy(x)
        
        for i from 1 to n:
            sum1 = 0
            sum2 = 0
            
            for j from 1 to i-1:
                sum1 += A[i][j] * x[j]
                
            for j from i+1 to n:
                sum2 += A[i][j] * x_old[j]
            
            x[i] = (b[i] - sum1 - sum2) / A[i][i]

        // Comprobar convergencia
        norm = 0
        for i from 1 to n:
            norm += (x[i] - x_old[i])^2

        if sqrt(norm) < epsilon:
            return x

    return x

function main():
    // Definir la matriz de coeficientes A y el vector de t√©rminos independientes b
    A = [
        [4, 1, 2],
        [3, 5, 1],
        [1, 1, 3]
    ]
    b = [4, 7, 3]

    // Definir el vector inicial x0, la tolerancia epsilon y el m√°ximo de iteraciones maxIter
    x0 = [0, 0, 0]
    epsilon = 0.0001
    maxIter = 100

    // Resolver el sistema de ecuaciones utilizando Gauss-Seidel
    solution = gaussSeidel(A, b, x0, epsilon, maxIter)
    print("Las soluciones son: " + solution)


## C√≥digo en Java.

public class GaussSeidel {
    public static void main(String[] args) {
        double[][] coeficientes = {
            {4, -1, 0, 0},
            {-1, 4, -1, 10},
            {0, -1, 4, 10}
        };
        /*
            x1 = 0.8928489685058594
            x2 = 3.5714244842529297
            x3 = 3.3928561210632324
        */
        
        
        double[] valoresIniciales = {0, 0, 0}; // Valores iniciales de las inc√≥gnitas
        double tolerancia = 0.0001; // Tolerancia para el criterio de convergencia
        int iteracionesMaximas = 1000; // N√∫mero m√°ximo de iteraciones
        
        double[] solucion = gaussSeidel(coeficientes, valoresIniciales, tolerancia, iteracionesMaximas);
        
        if (solucion != null) {
            System.out.println("Soluci√≥n:");
            for (int i = 0; i < solucion.length; i++) {
                System.out.println("x[" + i + "] = " + solucion[i]);
            }
        } else {
            System.out.println("El m√©todo no converge.");
        }
    }
    
    public static double[] gaussSeidel(double[][] coeficientes, double[] valoresIniciales, double tolerancia, int iteracionesMaximas) {
        int n = valoresIniciales.length;
        double[] solucion = new double[n];
        double[] solucionAnterior = new double[n];
        int iteraciones = 0;
        double error = tolerancia + 1;
        
        // Inicializar la soluci√≥n con los valores iniciales
        System.arraycopy(valoresIniciales, 0, solucion, 0, n);
        
        // Iterar hasta que se alcance la tolerancia o el n√∫mero m√°ximo de iteraciones
        while (error > tolerancia && iteraciones < iteracionesMaximas) {
            // Copiar la soluci√≥n anterior
            System.arraycopy(solucion, 0, solucionAnterior, 0, n);
            
            // Calcular la nueva soluci√≥n
            for (int i = 0; i < n; i++) {
                double suma = 0;
                for (int j = 0; j < n; j++) {
                    if (j != i) {
                        suma += coeficientes[i][j] * solucion[j];
                    }
                }
                solucion[i] = (coeficientes[i][n] - suma) / coeficientes[i][i];
            }
            
            // Calcular el error
            error = 0;
            for (int i = 0; i < n; i++) {
                error += Math.abs(solucion[i] - solucionAnterior[i]);
            }
            
            iteraciones++;
        }
        
        // Verificar la convergencia
        if (error <= tolerancia) {
            return solucion;
        } else {
            return null; // No converge
        }
    }
}

### Salida
![Captura de pantalla (383)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/fa63c45a-a050-4428-8b8b-f8238243a155)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema3/M%C3%A9todo%20de%20Gauss-Seidel)

********************************************************************************************************************************************
# Jacobi.
## Definici√≥n.
El m√©todo de Jacobi es un m√©todo iterativo utilizado para resolver sistemas de ecuaciones lineales. En este m√©todo, cada componente del vector soluci√≥n se calcula utilizando √∫nicamente los valores de la iteraci√≥n anterior. A diferencia del m√©todo de Gauss-Seidel, el m√©todo de Jacobi no usa las aproximaciones m√°s recientes dentro de la misma iteraci√≥n.
## Algoritmo.
1.-Inicializaci√≥n: Comienza con una estimaci√≥n inicial de las soluciones del sistema de ecuaciones lineales ùê¥ùë•=ùëè. Puedes empezar con un vector ùë•^(0).
2.-Iteraciones: Para cada iteraci√≥n ùëò.
3.-Criterio de parada: Repite el paso 2 hasta que se cumpla alg√∫n criterio de parada. Un criterio com√∫n es que la diferencia entre dos iteraciones consecutivas sea menor que una cierta tolerancia predefinida, o hasta que se alcance un n√∫mero m√°ximo de iteraciones.
4.-Salida: El vector ùë•^(ùëò)ser√° la aproximaci√≥n de la soluci√≥n del sistema de ecuaciones lineales.

function jacobi(A, b, x0, epsilon, maxIter):
    n = length(b)
    x = copy(x0)
    x_new = new array[n]

    for k from 1 to maxIter:
        for i from 1 to n:
            sum = 0
            
            for j from 1 to n:
                if j != i:
                    sum += A[i][j] * x[j]
            
            x_new[i] = (b[i] - sum) / A[i][i]

        // Comprobar convergencia
        norm = 0
        for i from 1 to n:
            norm += (x_new[i] - x[i])^2

        if sqrt(norm) < epsilon:
            return x_new

        x = copy(x_new)

    return x_new

function main():
    // Definir la matriz de coeficientes A y el vector de t√©rminos independientes b
    A = [
        [4, 1, 2],
        [3, 5, 1],
        [1, 1, 3]
    ]
    b = [4, 7, 3]

    // Definir el vector inicial x0, la tolerancia epsilon y el m√°ximo de iteraciones maxIter
    x0 = [0, 0, 0]
    epsilon = 0.0001
    maxIter = 100

    // Resolver el sistema de ecuaciones utilizando Jacobi
    solution = jacobi(A, b, x0, epsilon, maxIter)
    print("Las soluciones son: " + solution)


## C√≥digo en Java.

public class Jacobi {
    public static void main(String[] args) {
        double[][] coeficientes = {
            {10,1,2,3},
            {4,6,-1,9},
            {-2,3,8,51}
        };
        /*
        X1 = -1 
        X2 = 3
        X3 = 5
        */
        double[] valoresIniciales = {0, 0, 0}; // Valores iniciales de las inc√≥gnitas
        double tolerancia = 0.0001; // Tolerancia para el criterio de convergencia
        int iteracionesMaximas = 1000; // N√∫mero m√°ximo de iteraciones
        
        double[] solucion = jacobi(coeficientes, valoresIniciales, tolerancia, iteracionesMaximas);
        
        if (solucion != null) {
            System.out.println("Soluci√≥n:");
            for (int i = 0; i < solucion.length; i++) {
                System.out.println("x[" + i + "] = " + solucion[i]);
            }
        } else {
            System.out.println("El m√©todo no converge.");
        }
    }
    
    public static double[] jacobi(double[][] coeficientes, double[] valoresIniciales, double tolerancia, int iteracionesMaximas) {
        int n = valoresIniciales.length;
        double[] solucion = new double[n];
        double[] solucionAnterior = new double[n];
        int iteraciones = 0;
        double error = tolerancia + 1;
        
        // Inicializar la soluci√≥n con los valores iniciales
        System.arraycopy(valoresIniciales, 0, solucion, 0, n);
        
        // Iterar hasta que se alcance la tolerancia o el n√∫mero m√°ximo de iteraciones
        while (error > tolerancia && iteraciones < iteracionesMaximas) {
            // Copiar la soluci√≥n anterior
            System.arraycopy(solucion, 0, solucionAnterior, 0, n);
            
            // Calcular la nueva soluci√≥n
            for (int i = 0; i < n; i++) {
                double suma = 0;
                for (int j = 0; j < n; j++) {
                    if (j != i) {
                        suma += coeficientes[i][j] * solucionAnterior[j];
                    }
                }
                solucion[i] = (coeficientes[i][n] - suma) / coeficientes[i][i];
            }
            
            // Calcular el error
            error = 0;
            for (int i = 0; i < n; i++) {
                error += Math.abs(solucion[i] - solucionAnterior[i]);
            }
            
            iteraciones++;
        }
        
        // Verificar la convergencia
        if (error <= tolerancia) {
            return solucion;
        } else {
            return null; // No converge
        }
    }
}

### Salida
![Captura de pantalla (384)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/e916d544-d48f-4e5b-a3bb-603dde7007d1)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema3/M%C3%A9todo%20de%20Jacobi)
********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 4: Diferenciaci√≥n e Integraci√≥n Num√©rica
Aqu√≠ se cubren m√©todos para la diferenciaci√≥n e integraci√≥n de funciones. Se incluyen los m√©todos de Simpson 1/3, Simpson 3/8 y el m√©todo del trapecio.

# Simpson 1/3.
## Definici√≥n.
La regla de Simpson 1/3 es una t√©cnica de integraci√≥n num√©rica utilizada para aproximar el valor de una integral definida. Este m√©todo utiliza una interpolaci√≥n cuadr√°tica para conectar tres puntos equidistantes en el intervalo de integraci√≥n y calcula el √°rea bajo la curva utilizando la f√≥rmula de Simpson.
## Algoritmo.
1. f(x) que se desea integrar.
2. Especificar el intervalo de integraci√≥n,[a,b].
3. Dividir el intervalo [a,b] en n subintervalos de igual tama√±o, donde n es un n√∫mero par.
4. Calcular el ancho de cada subintervalo, h=(b‚àía)/2.
5. Calcular los valores de la funci√≥n f(x) en los extremos de los subintervalos: f(a),f(a+h),f(a+2h),‚Ä¶,f(b).
6. Calcular los valores de la funci√≥n f(x) en los puntos medios de los subintervalos: f(a+((h)/2)), f(a+((3h)/2)), ... , f(b+((h)/2)).
7. Aplicar la f√≥rmula de Simpson para calcular la aproximaci√≥n de la integral.
8. Devolver el valor calculado como la aproximaci√≥n de la integral.
   

function simpson13(f, a, b, n):
    h = (b - a) / n
    integral = f(a) + f(b) // Sumar los extremos

    for i from 1 to n-1 step 2:
        x0 = a + i * h
        x1 = x0 + h
        x2 = x1 + h
        integral += 4 * f(x1) + 2 * f(x2) // Aplicar la f√≥rmula de Simpson 1/3

    integral *= h / 3 // Multiplicar por el ancho del intervalo y dividir por 3

    return integral

function main():
    // Definir la funci√≥n f(x), los l√≠mites de integraci√≥n a y b, y el n√∫mero de intervalos n
    function f(x):
        return x^2

    a = 0
    b = 2
    n = 4

    // Calcular la aproximaci√≥n de la integral utilizando Simpson 1/3
    result = simpson13(f, a, b, n)
    print("El resultado de la integraci√≥n es: " + result)


## C√≥digo en Java.

import java.util.function.Function;
public class Simpson13_ {
     // M√©todo para calcular la aproximaci√≥n de la integral definida utilizando la Regla de Simpson de 1/3
     public static double reglaSimpson(double a, double b, int n, Function<Double, Double> f) {
        double h = (b - a) / n; // Calcula el ancho de cada subintervalo
        double suma = f.apply(a) + f.apply(b); // Suma los valores en los extremos

        // Suma los valores en los puntos internos, alternando entre multiplicaciones por 4 y 2
        for (int i = 1; i < n; i++) {
            double x = a + i * h;
            if (i % 2 == 0) {
                suma += 2 * f.apply(x);
            } else {
                suma += 4 * f.apply(x);
            }
        }

        return (h / 3) * suma;
    }

    public static void main(String[] args) {
        // Definir los l√≠mites de integraci√≥n y el n√∫mero de subintervalos
        double a = 0; // L√≠mite inferior de integraci√≥n
        double b = 0.8; // L√≠mite superior de integraci√≥n
        int n = 2; // N√∫mero de subintervalos

        // Definir la funci√≥n f(x) como una expresi√≥n lambda
        Function<Double, Double> funcion = x -> 0.2 + (25*x) - (200*Math.pow(x, 2)) + (675*Math.pow(x, 3)) - (900*Math.pow(x, 4)) + (400*Math.pow(x, 5));

        // Calcular la integral definida utilizando la Regla de Simpson de 1/3
        double resultado = reglaSimpson(a, b, n, funcion);
        System.out.println("El resultado de la integral definida es: " + resultado);
    }
}

### Salida
![Captura de pantalla (385)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/b08d9fc5-924d-49c1-b0e5-e2cfc72f3a42)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema4/MetodoReglaSimpson1_3)
********************************************************************************************************************************************
# Simpson 3/8.
## Definici√≥n.
La regla de Simpson 3/8 es una t√©cnica de integraci√≥n num√©rica utilizada para aproximar el valor de una integral definida. Este m√©todo utiliza una interpolaci√≥n c√∫bica para conectar cuatro puntos equidistantes en el intervalo de integraci√≥n y calcula el √°rea bajo la curva utilizando la f√≥rmula de Simpson 3/8.
## Algoritmo.
1 Definir la funci√≥n f(x).
2. Lea el l√≠mite inferior de integraci√≥n, el l√≠mite superior de integraci√≥n y n√∫mero de subintervalo.
3. C√°lculos: tama√±o del paso = (l√≠mite superior - l√≠mite inferior)/n√∫mero de subintervalo.
4. Establecer: valor de integraci√≥n = f(l√≠mite inferior) + f(l√≠mite superior).
5. Establecer: i = 1.
6. Si i > n√∫mero de subintervalo, entonces vaya a.
7. Calcular: k = l√≠mite inferior + i * h.
8. Si mod 3 = 0 entonces Valor de integraci√≥n = Valor de integraci√≥n + 2* f(k) De lo contrario Valor de integraci√≥n = Valor de integraci√≥n + 3 * f(k) Terminara si.
9. Incremente i en 1, es decir, i = i+1 y vaya al paso 7.
10. Calcule: Valor de integraci√≥n = Valor de integraci√≥n * tama√±o de paso*3/8.
11. Mostrar el valor de integraci√≥n como respuesta requerida.
12. Detener.

function simpson38(f, a, b, n):
    h = (b - a) / n
    integral = f(a) + f(b) // Sumar los extremos

    for i from 1 to n-1 step 3:
        x0 = a + i * h
        x1 = x0 + h
        x2 = x1 + h
        x3 = x2 + h
        integral += 3 * (f(x0) + 3 * f(x1) + 3 * f(x2) + f(x3)) // Aplicar la f√≥rmula de Simpson 3/8

    integral *= 3 * h / 8 // Multiplicar por el ancho del intervalo y dividir por 8

    return integral

function main():
    // Definir la funci√≥n f(x), los l√≠mites de integraci√≥n a y b, y el n√∫mero de intervalos n
    function f(x):
        return x^2

    a = 0
    b = 2
    n = 6

    // Calcular la aproximaci√≥n de la integral utilizando Simpson 3/8
    result = simpson38(f, a, b, n)
    print("El resultado de la integraci√≥n es: " + result)


## C√≥digo en Java.

import java.util.function.Function;
public class Simpson38_ {
// Funci√≥n para calcular la integral utilizando la regla de Simpson 3/8
public static double simpson38(Function<Double, Double> f, double a, double b, int n) {
    double h = (b - a) / n;
    double suma = f.apply(a) + f.apply(b);
    
    for (int i = 1; i < n; i++) {
        double x = a + i * h;
        if (i % 3 == 0) {
            suma += 2 * f.apply(x);
        } else {
            suma += 3 * f.apply(x);
        }
    }
    
    return (3 * h / 8) * suma;
}

// Ejemplo de uso
public static void main(String[] args) {
    // Definir la funci√≥n que queremos integrar
    Function<Double, Double> funcion = x -> 0.2 + (25*x) - (200*Math.pow(x, 2)) + (675*Math.pow(x, 3)) - (900*Math.pow(x, 4)) + (400*Math.pow(x, 5));

    // Definir los l√≠mites de integraci√≥n
    double a = 0; // L√≠mite inferior
    double b = 0.8; // L√≠mite superior

    // Definir el n√∫mero de subdivisiones (debe ser m√∫ltiplo de 3)
    int n = 3;

    // Calcular la aproximaci√≥n de la integral
    double integral = simpson38(funcion, a, b, n);

    // Imprimir el resultado
    System.out.println("Aproximaci√≥n de la integral: " + integral);
}
}

### Salida
![Captura de pantalla (386)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/cc5cdae2-1310-4aa2-9e61-38e6c7ff94ee)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema4/MetodoReglaSimpson3_8)
********************************************************************************************************************************************
# Trapecio.
## Definici√≥n.
El m√©todo del trapecio es una t√©cnica de integraci√≥n num√©rica utilizada para aproximar el valor de una integral definida. La idea detr√°s del m√©todo del trapecio es aproximar el √°rea bajo una curva mediante un conjunto de trapecios cuyas bases son segmentos de la curva y cuyas alturas son la distancia entre los puntos de la partici√≥n. En esencia, se aproxima el √°rea bajo la curva como la suma de las √°reas de los trapecios.
## Algoritmo.
1. Definir el intervalo de integraci√≥n [a, b] y el n√∫mero de subintervalos n en los que se dividir√° el intervalo.
2. Calcular el ancho de cada subintervalo: h = (b - a) / n
3. Evaluar la funci√≥n en los puntos extremos del intervalo (a y b) y en los puntos intermedios (xi = a + i*h, donde i = 1, 2, ..., n-1).
4. Calcular la aproximaci√≥n de la integral definida utilizando la f√≥rmula del trapecio: Integral aproximada = (h/2) * (f(a) + 2*[f(x1) + f(x2) + ... + f(xn-1)] + f(b)) Donde f(a), f(b) y f(xi) son los valores de la funci√≥n evaluada en los puntos correspondientes.
5. Cuantos m√°s subintervalos se tomen (es decir, mayor sea n), m√°s precisa ser√° la aproximaci√≥n de la integral.

Funci√≥n Trapecio(f, a, b, n):
    h = (b - a) / n
    suma = 0.5 * (f(a) + f(b)) // Sumamos el valor de f(a) y f(b) al resultado
    Para i desde 1 hasta n-1:
        xi = a + i * h // Calculamos los puntos de partici√≥n
        suma = suma + f(xi) // Sumamos el valor de f(xi) al resultado
    resultado = h * suma // Multiplicamos por el ancho de los trapecios
    Devolver resultado

## C√≥digo en Java.

import java.util.function.Function;
public class Trapecio {
// M√©todo para calcular la aproximaci√≥n de la integral definida utilizando el m√©todo del trapecio
public static double metodoTrapecio(double a, double b, int n, Function<Double, Double> f) {
    double h = (b - a) / n; // Calcula el ancho de cada subintervalo
    double suma = 0.5 * (f.apply(a) + f.apply(b)); // Suma los valores en los extremos
    // Suma los valores en los puntos internos
    for (int i = 1; i < n; i++) {
        double x = a + i * h;
        suma += f.apply(x);
    }
    return h * suma;
}

public static void main(String[] args) {
    double a = 1.3; // L√≠mite inferior de integraci√≥n
    double b = 1.8; // L√≠mite superior de integraci√≥n
    int n = 1; // N√∫mero de subintervalos
    // Definir la funci√≥n f(x) como una expresi√≥n lambda
    Function<Double, Double> funcion = x ->  Math.pow(x, 3) - (6*Math.pow(x, 2)) + (11*x) - 6;
    // Calcular la integral definida utilizando el m√©todo del trapecio
    double resultado = metodoTrapecio(a, b, n, funcion);
    System.out.println("El resultado de la integral definida es: " + resultado);
}
}

### Salida
![Captura de pantalla (387)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/0af931b1-bfca-43c6-932c-f96704890ab8)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema4/MetodoTrapecio)

********************************************************************************************************************************************
# Tema 5: Interpolaci√≥n y Ajuste de Funciones
En este tema se estudian t√©cnicas de interpolaci√≥n y ajuste de funciones, como la interpolaci√≥n cuadr√°tica, lineal, de Lagrange y de Newton.
# Interpolaci√≥n Cuadr√°tica.
## Definici√≥n.
para mejorar la estimaci√≥n consiste en introducir alguna curvatura a la l√≠nea que une los puntos. Si se tienen tres puntos como datos, √©stos pueden ajustarse en un polinomio de segundo grado (tambi√©n conocido como polinomio cuadr√°tico o par√°bola).
## Algoritmo.
1. Definir los puntos conocidos.
2. Formar el Sistema de Ecuaciones.
3. Resolver el Sistema de Ecuaciones.
4. Formar el Polinomio Interpolante.

Algoritmo InterpolacionCuadratica(x0, y0, x1, y1, x2, y2, x)
    Entrada:
        x0, y0: coordenadas del primer punto conocido
        x1, y1: coordenadas del segundo punto conocido
        x2, y2: coordenadas del tercer punto conocido
        x: valor de x para el cual queremos estimar el valor de y
    Salida:
        y: valor interpolado de y

    // Paso 1: Calcular los coeficientes a, b y c
    a = ((y2 - y0) / ((x2 - x0) * (x2 - x1)) - (y1 - y0) / ((x1 - x0) * (x2 - x1))) / (x2 - x0)
    b = (y1 - y0) / (x1 - x0) - a * (x1 + x0)
    c = y0 - a * x0^2 - b * x0
    
    // Paso 2: Calcular el valor interpolado de y
    y = a * x^2 + b * x + c
    
    Retornar y
Fin Algoritmo

## C√≥digo en Java.

public class Interpolacion_cuadratica {

    public static void main(String[] args) {
         // Datos de ejemplo
        double x0 = 1.0;
        double x1 = 2.0;
        double x2 = 3.0;
        double y0 = 3.0;
        double y1 = 5.0;
        double y2 = 9.0;
        double x = 2.5;
        // Realizar interpolaci√≥n cuadr√°tica
        double resultado = interpolacionCuadratica(x0, x1, x2, y0, y1, y2, x);
        System.out.println("El resultado de la interpolaci√≥n cuadr√°tica en x = " + x + " es: " + resultado);
    }
    
    public static double interpolacionCuadratica(double x0, double x1, double x2, double y0, double y1, double y2, double x) {
        double L0 = ((x - x1) * (x - x2)) / ((x0 - x1) * (x0 - x2));
        double L1 = ((x - x0) * (x - x2)) / ((x1 - x0) * (x1 - x2));
        double L2 = ((x - x0) * (x - x1)) / ((x2 - x0) * (x2 - x1));

        double result = (y0 * L0) + (y1 * L1) + (y2 * L2);
        return result;
    }
}

### Salida
![331050435-913d39b9-aca9-455d-ac3e-59bd85932344](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/cb5e5c3c-6903-49c6-98e4-0916f55c8074)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema5/Interpolaci%C3%B3n_de_M%C3%ADnimos_Cuadrado)
********************************************************************************************************************************************
# Interpolaci√≥n Lineal.
## Definici√≥n.
La forma m√°s simple de interpolaci√≥n consiste en unir dos puntos con una l√≠nea recta. Dicha t√©cnica es llamada interpolaci√≥n lineal. La notaci√≥n f1(x) designa que √©ste es un polinomio de interpolaci√≥n de primer grado. Observe que adem√°s de representar la pendiente de la l√≠nea que une los puntos, el t√©rmino f(x1) ‚Äì f(x0)/(x1 ‚Äì x0) es una aproximaci√≥n en diferencia dividida finita a la primer derivada
## Algoritmo.
1. Definir los puntos conocidos.
2. Calcular la Pendiente.
3. Calcular la Intersecci√≥n.
4. Formar la Ecuaci√≥n de la Recta.
5. Calcular el Valor Interpolado.

Algoritmo InterpolacionLineal(x0, y0, x1, y1, x)
    Entrada:
        x0, y0: coordenadas del primer punto conocido
        x1, y1: coordenadas del segundo punto conocido
        x: valor de x para el cual queremos estimar el valor de y
    Salida:
        y: valor estimado de y

    // Paso 1: Calcular la pendiente (m)
    m <- (y1 - y0) / (x1 - x0)
    
    // Paso 2: Calcular el valor interpolado de y
    y <- y0 + m * (x - x0)
    
    Retornar y
Fin Algoritmo

## C√≥digo en Java.

public class InterpolacionLineal {

    // M√©todo para realizar la interpolaci√≥n lineal
    public static double interpolacionLineal(double x0, double y0, double x1, double y1, double x) {
        // Calcular la pendiente (m)
        double m = (y1 - y0) / (x1 - x0);
        // Calcular el valor interpolado de y
        return y0 + m * (x - x0);
    }

    public static void main(String[] args) {
        // Puntos conocidos
        double x0 = 1.0, y0 = 2.0;
        double x1 = 3.0, y1 = 3.0;
        // Valor de x para el cual queremos estimar y
        double x = 2.0;
        
        // Calcular el valor interpolado de y
        double y = interpolacionLineal(x0, y0, x1, y1, x);
        
        // Imprimir el resultado
        System.out.println("El valor interpolado de y para x=" + x + " es " + y);
    }
}

### Salida
![331012519-d3901a4a-668d-4317-9815-c74ab3e87653](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/5a7b08ac-ccb0-48d7-afcf-e10a3660fdfb)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema5/Interpolaci%C3%B3n_Lineal)
********************************************************************************************************************************************
# Lagrange.
## Definici√≥n.
La interpolaci√≥n de Lagrange es un m√©todo de interpolaci√≥n polin√≥mica que utiliza un polinomio de grado n-1 para aproximar una funci√≥nf(x) a partir de n puntos conocidos.
El polinomio de Lagrange P(x) se construye como una combinaci√≥n lineal de los polinomios base de Lagrange Li(x).
## Algoritmo.
1. Obtener los puntos (x0, y0), (x1, y1), ..., (xn, yn).
2. Calcular los polinomios de Lagrange Li(x) para cada punto (xi, yi).
3. Construir el polinomio interpolante P(x) como la suma ponderada de los polinomios de Lagrange.
4. Evaluar el polinomio interpolante P(x) en el punto deseado x_eval.

function lagrangeInterpolation(x_vals, y_vals, x):
    n = length(x_vals)
    P = 0

    for i from 0 to n-1:
        Li = 1
        for j from 0 to n-1:
            if j != i:
                Li *= (x - x_vals[j]) / (x_vals[i] - x_vals[j])
        P += y_vals[i] * Li

    return P

function main():
    // Definir los puntos conocidos
    x_vals = [0, 1, 2]
    y_vals = [1, 3, 2]

    // Definir el punto donde se quiere interpolar
    x = 1.5

    // Calcular la interpolaci√≥n de Lagrange
    resultado = lagrangeInterpolation(x_vals, y_vals, x)
    print("El valor interpolado en x =", x, "es", resultado)


## C√≥digo en Java.

import java.util.ArrayList;
import java.util.List;
public class Lagrange {
    // M√©todo para calcular el polinomio de Lagrange
    public static double lagrange(List<Double> x, List<Double> y, double xi) {
        double result = 0;

        for (int i = 0; i < x.size(); i++) {
            double term = y.get(i);
            for (int j = 0; j < x.size(); j++) {
                if (j != i) {
                    term = term * (xi - x.get(j)) / (x.get(i) - x.get(j));
                }
            }
            result += term;
        }

        return result;
    }

    public static void main(String[] args) {
        // Puntos conocidos
        List<Double> x = new ArrayList<>();
        List<Double> y = new ArrayList<>();

        // Agregar puntos conocidos (x, y)
        x.add(1.0);
        x.add(2.0);
        x.add(3.0);
        y.add(2.0);
        y.add(3.0);
        y.add(5.0);

        // Punto donde queremos aproximar
        double xi = 2.5;

        // Calcular el valor aproximado usando el m√©todo de Lagrange
        double result = lagrange(x, y, xi);
        System.out.println("El valor aproximado en x = " + xi + " es: " + result);
    }
}

### Salida
