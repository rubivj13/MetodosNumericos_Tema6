# Métodos Númericos

## índice
+ Introducción
+ [Tema 1: Introducción a los métodos numéricos.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/blob/main/README.md#tema-1-introducci%C3%B3n-a-los-m%C3%A9todos-num%C3%A9ricos)
  - [Overflow.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/blob/main/README.md#overflow)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Redondeo.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#redondeo)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Truncamiento.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#truncamiento)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 2: Métodos de solución de ecuaciones.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-2-m%C3%A9todos-de-soluci%C3%B3n-de-ecuaciones)
  - [Bisección.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#bisecci%C3%B3n)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Regla falsa.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#regla-falsa)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Secante.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#secante)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 3: Métodos de solución de sistemas de ecuaciones.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-3-m%C3%A9todos-de-soluci%C3%B3n-de-sistemas-de-ecuaciones)
  - [Eliminación Gaussiana.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#eliminaci%C3%B3n-gaussiana)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Gauss-Jordan.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#gauss-jordan)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Gauss-Seidel.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#gauss-seidel)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Jacobi.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#jacobi)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 4: Diferenciación e integración numérica.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-4-diferenciaci%C3%B3n-e-integraci%C3%B3n-num%C3%A9rica)
  - [Simpson 1/3.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#simpson-13)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Simpson 3/8.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#simpson-38)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Trapecio.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#trapecio)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 5: Interpolación y ajuste de funciones.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-5-interpolaci%C3%B3n-y-ajuste-de-funciones)
  - [Interpolación cuadrática.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#interpolaci%C3%B3n-cuadr%C3%A1tica)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Interpolación lineal.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#interpolaci%C3%B3n-lineal)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Lagrange.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#lagrange)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Newton.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#newton)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 6: Solución de ecuaciones diferenciales.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-6-soluci%C3%B3n-de-ecuaciones-diferenciales)
  - [Euler.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#euler)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Runge-Kutta.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#runge-kutta)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Taylor.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#taylor)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.

# Introducción
Los métodos numéricos son técnicas matemáticas que permiten encontrar soluciones aproximadas a problemas complejos que no pueden resolverse de manera analítica. Estos métodos son fundamentales en diversas áreas de la ingeniería, la física, la economía y otras disciplinas que requieren soluciones precisas a problemas matemáticos complicados. En este repositorio, exploraremos una variedad de métodos numéricos, desde los más básicos hasta los más avanzados, implementados en el lenguaje de programación Java.

********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 1: Introducción a los Métodos Numéricos
Este primer tema proporciona una base sólida sobre conceptos esenciales como el overflow, el redondeo y el truncamiento. Se define cada concepto, se explica el algoritmo correspondiente y se proporciona código en Java junto con ejercicios prácticos.
# Overflow.
## Definición
El overflow (desbordamiento) es un fenómeno que ocurre en los cálculos numéricos cuando un resultado excede el rango máximo que puede ser representado por el tipo de dato utilizado en un sistema informático. Esto puede provocar resultados incorrectos y comportamientos inesperados en los programas.

## Algoritmo
1. Definir los límites del tipo de dato.
2. Verificar las condiciones de overflow antes de realizar la operación.
3. Implementar la lógica para lanzar una excepción o manejar el overflow si se detecta.


function safeAdd(x, y):
    if x > 0 and y > 0 and x > MAX_INT - y:
        throw OverflowException("Overflow positivo detectado")
    else if x < 0 and y < 0 and x < MIN_INT - y:
        throw OverflowException("Overflow negativo detectado")
    else:
        return x + y

function main():
    a = MAX_INT
    b = 1
    
    try:
        result = safeAdd(a, b)
        print("Resultado de la suma: " + result)
    except OverflowException as e:
        print("Overflow detectado: " + e.message)

## Código en Java

public class Overflow {
    public static void main(String[] args) {
        // Ejemplo de desbordamiento en operaciones aritméticas con enteros
        int a = Integer.MAX_VALUE; // Valor máximo para un entero
        int b = 1; // Incremento en 1

        // Intentamos incrementar el valor máximo de un entero
        int suma = a + b;

        // Imprimimos el resultado
        System.out.println("Resultado de la suma: " + suma); // Se produce un desbordamiento
    }
}

### Salida
![Captura de pantalla (374)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/6f3ccc8e-502d-4196-b214-1b5e7ae937a9)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema1/Overflow) 

********************************************************************************************************************************************

# Redondeo.
## Definición.
El redondeo es una técnica utilizada en aritmética y computación para reducir el número de cifras significativas de un número, ajustándolo al valor más cercano con una precisión especificada. Este proceso es comúnmente empleado para manejar la representación de números en sistemas digitales, donde es necesario limitar la cantidad de dígitos debido a restricciones de memoria o precisión.
## Algoritmo.
1. Obtener el número decimal a redondear.
2. Separar la parte entera y la parte fraccionaria del número.
3. Evaluar la parte fraccionaria:
  Si la parte fraccionaria es mayor o igual a 0.5, aumentar la parte entera en 1.
  Si la parte fraccionaria es menor a 0.5, mantener la parte entera sin cambios.
4. El resultado es la parte entera ajustada según el paso anterior.
   

function roundToNearestInteger(number):
    // Separar la parte entera y la parte fraccionaria
    integerPart = floor(number)
    fractionalPart = number - integerPart

    // Evaluar la parte fraccionaria
    if fractionalPart >= 0.5:
        return integerPart + 1
    else:
        return integerPart

function main():
    number = 3.7
    result = roundToNearestInteger(number)
    print("Número original: " + number)
    print("Número redondeado: " + result)


## Código en Java.

public class Redondeo {
    public static void main(String[] args) {
        // Ejemplo de error de redondeo en suma
        double num1 = 0.1;
        double num2 = 0.2;
        double suma = num1 + num2;

        System.out.println("Suma: " + suma); // Imprime 0.30000000000000004

        // Ejemplo de error de redondeo en multiplicación
        double num3 = 1.0 / 3.0;
        double resultado = num3 * 3;

        System.out.println("Resultado: " + resultado); // Imprime 0.9999999999999999
    }
}

### Salida
![Captura de pantalla (375)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/f554669d-c8f3-4c87-932a-f8e4a9af4533)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema1/Redondeo)

********************************************************************************************************************************************
# Truncamiento.
## Definición.
El truncamiento es una técnica utilizada en aritmética y computación para reducir el número de cifras decimales de un número sin redondear. Se elimina la parte fraccionaria del número, acercándolo al valor entero más cercano hacia cero. Este proceso es útil en situaciones donde se requiere un valor entero sin importar el valor de la parte fraccionaria.
## Algoritmo.
1. Obtener el número decimal a truncar.
2. Separar la parte entera del número.
3. Eliminar la parte fraccionaria del número.
4. El resultado es la parte entera del número.
   

function truncateNumber(number):
    // Separar la parte entera
    integerPart = floor(abs(number))

    // Restaurar el signo del número original
    if number < 0:
        return -integerPart
    else:
        return integerPart

function main():
    number = 3.7
    result = truncateNumber(number)
    print("Número original: " + number)
    print("Número truncado: " + result)

    number = -3.7
    result = truncateNumber(number)
    print("Número original: " + number)
    print("Número truncado: " + result)

## Código en Java.

public class Truncamiento {
    public static void main(String[] args) {
        // Ejemplo de error de truncamiento en la aproximación de una serie infinita
        int n = 10; // Número de términos a considerar en la serie
        double x = 0.5; // Valor en el que evaluamos la serie
        double suma = 0.0;

        for (int i = 0; i < n; i++) {
            suma += Math.pow(-1, i) * Math.pow(x, 2 * i + 1) / factorial(2 * i + 1);
        }

        System.out.println("Aproximación de la serie: " + suma); // Imprime un valor aproximado
    }

    // Método para calcular el factorial de un número
    public static int factorial(int n) {
        int fact = 1;
        for (int i = 1; i <= n; i++) {
            fact *= i;
        }
        return fact;
    }
}

### Salida
![Captura de pantalla (376)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/488313b6-a23e-4347-9aae-8abcdfb1cab3)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema1/Truncamiento)
********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 2: Métodos de Solución de Ecuaciones
Aquí se exploran técnicas para resolver ecuaciones no lineales. Los métodos de bisección, regla falsa y secante se presentan con sus definiciones, algoritmos detallados, implementaciones en Java y ejercicios prácticos.
# Bisección.
## Definición.
El método de bisección es un método numérico utilizado para encontrar las raíces de una función continua. Consiste en dividir repetidamente un intervalo en dos partes y seleccionar el subintervalo en el que existe un cambio de signo de la función, lo que indica la presencia de una raíz. Este proceso se repite hasta que se alcanza un intervalo suficientemente pequeño, proporcionando una aproximación de la raíz.
## Algoritmo.
1. Definir la función ( f(x) ) y los extremos del intervalo ([a, b]) tal que ( f(a) \cdot f(b) < 0 ).
2. Calcular el punto medio ( c = \frac{a + b}{2} ).
3. Evaluar ( f(c) ).
Si ( f(c) = 0 ) o el intervalo es suficientemente pequeño (criterio de convergencia), entonces ( c ) es la raíz.
Si ( f(a) \cdot f(c) < 0 ), entonces la raíz está en el intervalo ([a, c]). De lo contrario, la raíz está en ([c, b]).
4. Repetir el proceso con el nuevo intervalo hasta que se cumpla el criterio de convergencia.


function bisection(f, a, b, epsilon):
    if f(a) * f(b) >= 0:
        throw Exception("El intervalo no contiene una raíz")

    while (b - a) / 2 > epsilon:
        c = (a + b) / 2
        if f(c) == 0:
            return c // La raíz exacta es encontrada
        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

    return (a + b) / 2 // Aproximación de la raíz

function main():
    // Definir la función f(x)
    function f(x):
        return x^3 - x - 2

    // Definir el intervalo inicial [a, b] y la tolerancia epsilon
    a = 1
    b = 2
    epsilon = 0.0001

    try:
        root = bisection(f, a, b, epsilon)
        print("La raíz aproximada es: " + root)
    except Exception as e:
        print(e.message)
  
## Código en Java.

/*
 * Descripcion del ejemplo

    Función: x^3+4x^2-10    Limites: A:1 B:2    Error: 0.0001    Iteraciones: 6

    Implementacion (resultado a 5 cifras significativas)

    1.36719
 * 
 */

import java.util.Scanner;
public class Biseccion {
    public static void main(String[] args) {
        System.out.println(" EJECICIO 1 METODO DE BISECCION ");
        // Crear un objeto Scanner para leer la entrada del usuario
        Scanner scanner = new Scanner(System.in);

        System.out.print("Ingrese el límite inferior: ");
        double a = scanner.nextDouble();

        System.out.print("Ingrese el límite superior: ");
        double b = scanner.nextDouble();

        // Pedir al usuario que ingrese el número máximo de iteraciones
        System.out.print("Ingrese el número máximo de iteraciones: ");
        int maxIter = scanner.nextInt();

        // Pedir al usuario que ingrese el valor de tolerancia (error aceptable)
        System.out.print("Ingrese el valor de tolerancia: ");
        // Leer el valor de tolerancia (error aceptable) desde el usuario
        double tol = scanner.nextDouble();

        // Encontrar la raíz de la función usando el método de bisección
        double root = bisectionMethod(a, b, maxIter, tol);

        // Imprimir el resultado
        System.out.printf("La raíz de la ecuación es: %.5f%n", root);
        /*
         Esta parte %.5f%n sirve para dejar el numero decimal con 5 digitos despues del punto decimal
        */
    }

    // Definir el método de bisección
    public static double bisectionMethod(double a, double b, int maxIter, double tol) {
        // Verificar si la función cambia de signo en el intervalo
        if ((func(a) * func(b)) > 0) {
            System.out.println("El método no puede encontrar una raíz en el intervalo.");
            return -1;
        }

        double c;
        // repetir hasta que se alcance el número máximo de iteraciones
        for (int i = 0; i < maxIter; i++) {
            // Calcular el punto medio del intervalo
            c = (a + b) / 2;
            // Verificar si el punto medio está dentro de la tolerancia (error aceptable)
            if (Math.abs(func(c)) < tol) {
                // Devolver el punto medio como la raíz
                return c;
            }
            // Actualizar el intervalo
            if (func(a) * func(c) < 0) {
                b = c;
            } else {
                a = c;
            }
        }
        // Devolver el punto medio del intervalo final como la raíz
        return (a + b) / 2;
    }

    // Definir la función para encontrar la raíz de
    public static double func(double x) {
        return Math.pow(x, 3) + 4 * Math.pow(x, 2) - 10;
    }
}

### Salida
![Captura de pantalla (377)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/c239f15a-eaf3-4ef5-a441-d196be505e15)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema2/M%C3%A9todo%20de%20bisecci%C3%B3n)
********************************************************************************************************************************************
# Regla Falsa.
## Definición.
El método de la regla falsa, también conocido como método de interpolación lineal o método de la secante, es un método numérico para encontrar raíces de funciones continuas. A diferencia del método de bisección, que divide el intervalo por la mitad, la regla falsa utiliza una interpolación lineal entre los puntos finales del intervalo para estimar la raíz. Este método converge más rápidamente que el método de bisección en ciertos casos.
## Algoritmo.
1. Definir f(x).
2. Definir los intervalos [a,b].
3. Defiinr el umbral.
4. Calcular el punto de intersección 𝑐 de la línea que une (af(a) y (b,f(b)).
5. Evaluar f(c).
6. Repetir los pasos anteriores hasta que se cumpla la condición de parada.


function falsePosition(f, a, b, epsilon):
    if f(a) * f(b) >= 0:
        throw Exception("El intervalo no contiene una raíz")

    while |b - a| > epsilon:
        // Calcular el punto c usando interpolación lineal
        c = b - (f(b) * (b - a)) / (f(b) - f(a))
        
        // Evaluar f(c)
        if f(c) == 0:
            return c // La raíz exacta es encontrada
        if |f(c)| < epsilon:
            return c // Aproximación de la raíz dentro de la tolerancia
        
        // Actualizar los límites del intervalo
        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

    return c // Aproximación de la raíz

function main():
    // Definir la función f(x)
    function f(x):
        return x^3 - x - 2

    // Definir el intervalo inicial [a, b] y la tolerancia epsilon
    a = 1
    b = 2
    epsilon = 0.0001

    try:
        root = falsePosition(f, a, b, epsilon)
        print("La raíz aproximada es: " + root)
    except Exception as e:
        print(e.message)


## Código en Java.

/*
 * Descripción del ejemplo

    Función: x^4-9x^3+6  Limites: A:0  B:1    Error: 0.0001  Iteraciones: 6

    Implementación (resultado a 5 cifras significativas)

    0.90499
 */

import java.util.Scanner;

public class ReglaFalsa {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
 
        System.out.println("EJERCICIO 1 DE METODO DE LA REGLA FALSA ");
 
        System.out.print("Ingrese el límite inferior: ");
        double a = scanner.nextDouble();
 
        System.out.print("Ingrese el límite superior: ");
        double b = scanner.nextDouble();
 
        System.out.print("Ingrese el número máximo de iteraciones: ");
        int maxIter = scanner.nextInt();
 
        System.out.print("Ingrese el valor de tolerancia: ");
        double tol = scanner.nextDouble();
 
        // Se calcula la raíz de la ecuación utilizando el método de la posición falsa
        double root = metodoReglaFalsa(a, b, maxIter, tol);
 
        // Se imprime el resultado en formato decimal con 5 cifras después del punto decimal
        System.out.printf("La raíz de la ecuación es: %.5f%n", root);
     }
 
     // Método que implementa el algoritmo de la posición falsa
     public static double metodoReglaFalsa(double a, double b, int maxIter, double tol) {
        // Se verifica si la función cambia de signo en el intervalo [a, b]
        if (func(a) * func(b) > 0) {
            System.out.println("El método no puede encontrar una raíz en el intervalo.");
            return -1;
        }
        
        // Declarar las variables
        double xa, xb, xr = 0;
        xa = a;
        xb = b;
 
        for (int i = 0; i < maxIter; i++) {
            xr = xb - (func(xb) * (xb - xa) / (func(xb) - func(xa)));
            if (Math.abs(func(xr)) < tol) {
                // Si la diferencia absoluta de la función en x2 es menor que la tolerancia, se devuelve x2 como la raíz
                return xr;
            }
            if (func(xa) * func(xr) < 0) {
                // Si la función cambia de signo entre x0 y x2, se actualiza x1
                xb = xr;
            } else {
                // De lo contrario, se actualiza x0
                xa = xr;
            }
        }
        // Si se alcanza el número máximo de iteraciones sin encontrar una raíz con la tolerancia especificada, se devuelve el último valor de x2 como la raíz aproximada
        return xr;
    }
 
     // Método que define la función cuya raíz se desea encontrar
     public static double func(double x) {
        return Math.pow(x, 4) - 9 * Math.pow(x, 3) + 6;
     }
}

### Salida
![Captura de pantalla (378)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/e84fbc41-bc8b-4c7d-bb8a-9990e9016ffe)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema2/M%C3%A9todo%20de%20la%20falsa%20posici%C3%B3n)
********************************************************************************************************************************************
# Secante.
## Definición.
El método de la secante es un método numérico para encontrar raíces de una función continua. Es similar al método de la regla falsa, pero en lugar de mantener un intervalo que contiene la raíz, utiliza dos aproximaciones sucesivas de la raíz para iterativamente acercarse a la solución. Este método generalmente converge más rápido que el método de bisección y la regla falsa.
## Algoritmo.
1. Definir f(x).
2. Definir dos aproximaciones iniciales X0 y X1.
3. Definir el umbral de tolerancia.
4. Para i=1 hasta maxIter.
5. Calcular Xi+1 usando la formula.
6. Retornar Xi+1 como la raíz aproximada si se ha alcanzado la tolerancia, o el valor más cercano después de maxIter iteraciones.

function secant(f, x0, x1, epsilon, maxIter):
    for i from 1 to maxIter:
        // Calcular x2 usando la fórmula de la secante
        x2 = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0))

        // Verificar si la diferencia es menor que la tolerancia
        if |x2 - x1| < epsilon:
            return x2 // La raíz aproximada es encontrada
        
        // Actualizar las aproximaciones
        x0 = x1
        x1 = x2

    return x2 // Aproximación de la raíz después de maxIter iteraciones

function main():
    // Definir la función f(x)
    function f(x):
        return x^3 - x - 2

    // Definir las aproximaciones iniciales x0, x1, la tolerancia epsilon y el máximo de iteraciones maxIter
    x0 = 1
    x1 = 2
    epsilon = 0.0001
    maxIter = 100

    try:
        root = secant(f, x0, x1, epsilon, maxIter)
        print("La raíz aproximada es: " + root)
    except Exception as e:
        print(e.message)


## Código en Java.

/*
 * Descripción del ejemplo

    Función: x^2-3x-4  Limites: A: 3.5 B: 4.5   Error: 0.0001   Iteraciones: 6

    Implementación (Resultado a 5 cifras decimales)

    4.00000
    4
 */
import java.util.Scanner;
public class Secante {
    public static void main(String[] args) {
        
        System.out.println(" EJEMPLO 1 METODO DE SECANTE ");
        
        Scanner scanner = new Scanner(System.in);

        System.out.print("Ingrese Xi: ");
        double x0 = scanner.nextDouble(); // Leer Xi "a"
        System.out.print("Ingrese Xi-1: ");
        double x1 = scanner.nextDouble(); // Leer Xi-1 "b"
        System.out.print("Ingrese el número máximo de iteraciones: ");
        int maxIter = scanner.nextInt(); // Leer el número máximo de iteraciones 
        System.out.print("Ingrese el valor de tolerancia: ");
        double tol = scanner.nextDouble(); // Leer el valor de tolerancia 

        double root = metodoSecante(x0, x1, maxIter, tol); // Llamar al método metodoSecante 

        System.out.printf("La raíz de la ecuación es: %.5f%n", root); // Imprimir el resultado del método metodoSecante con 5 dígitos de precisión después del punto decimal
    }

    public static double metodoSecante(double x0, double x1, int maxIter, double tol) {
        if (func(x0) * func(x1) == 0) {
            System.out.println("El método no puede encontrar una raíz."); // Verificar 
            return -1;
        }

        double x2 = 0;
        for (int i = 0; i < maxIter; i++) {
            x2 = x1 - (func(x1) * (x1 - x0) / (func(x1) - func(x0))); // Calcular la siguiente aproximacion usando el método de la secante
            if (Math.abs(x1 - x2) < tol) {
                return x2; // Si el cambio en las aproximaciones es menor que el valor de tolerancia, devolver la aproximacion actual como la raíz
            }
            x0 = x1; // Actualizar el valor de x0
            x1 = x2; // Actualizar el valor de x1
        }
        return x2; // Si se alcanza el número máximo de iteraciones sin encontrar una raíz con la tolerancia especificada, devolver la última aproximacion
    }

    public static double func(double x) {
        return Math.pow(x, 2) - 3 * x - 4; // Definir la función cuya raíz se desea encontrar
    }
}

### Salida
![Captura de pantalla (379)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/04d5ec24-efcc-4913-8f35-7a7886dc9790)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema2/M%C3%A9todo%20de%20la%20secante)
********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 3: Métodos de Solución de Sistemas de Ecuaciones
Este tema aborda métodos para resolver sistemas de ecuaciones lineales. Se incluyen la eliminación gaussiana, Gauss-Jordan, Gauss-Seidel y Jacobi.
# Eliminación Gaussiana.
## Definición.
La eliminación gaussiana es un método algebraico utilizado para resolver sistemas de ecuaciones lineales. Consiste en transformar el sistema de ecuaciones en una forma escalonada (triangular superior) utilizando operaciones elementales de fila. Una vez en esta forma, se aplica la sustitución regresiva para encontrar las soluciones del sistema.
## Algoritmo.
1. Formación de la Matriz Aumentada: Formar la matriz aumentada del sistema de ecuaciones A|b donde A es la matriz de coeficientes y b es el vector de términos independientes.
2. ransformación a Forma Escalonada: Para cada fila i desde 1 hasta n.
3. Pivoteo: Seleccionar el elemento con el mayor valor absoluto en la columna i de las filas i a n (pivoteo parcial) y permutar la fila actual con la fila del pivote si es necesario.
4. Eliminación hacia adelante: Para cada fila j desde +i+1 hasta n.
5. Sustitución Regresiva: Inicializar el vector solución x de tamaño n.

function gaussianElimination(A, b):
    n = length(b)
    // Formar la matriz aumentada
    augmentedMatrix = augmentMatrix(A, b)

    // Transformar a forma escalonada
    for i from 1 to n:
        // Pivoteo parcial
        maxRow = i
        for k from i+1 to n:
            if abs(augmentedMatrix[k][i]) > abs(augmentedMatrix[maxRow][i]):
                maxRow = k
        swapRows(augmentedMatrix, i, maxRow)
        
        // Eliminación hacia adelante
        for j from i+1 to n:
            m = augmentedMatrix[j][i] / augmentedMatrix[i][i]
            for k from i to n+1:
                augmentedMatrix[j][k] -= m * augmentedMatrix[i][k]

    // Sustitución regresiva
    x = new array[n]
    for i from n down to 1:
        sum = 0
        for j from i+1 to n:
            sum += augmentedMatrix[i][j] * x[j]
        x[i] = (augmentedMatrix[i][n+1] - sum) / augmentedMatrix[i][i]

    return x

function augmentMatrix(A, b):
    augmentedMatrix = new matrix[length(b)][length(b)+1]
    for i from 1 to length(b):
        for j from 1 to length(b):
            augmentedMatrix[i][j] = A[i][j]
        augmentedMatrix[i][length(b)+1] = b[i]
    return augmentedMatrix

function swapRows(matrix, row1, row2):
    temp = matrix[row1]
    matrix[row1] = matrix[row2]
    matrix[row2] = temp

function main():
    // Definir la matriz de coeficientes A y el vector de términos independientes b
    A = [
        [2, 1, -1],
        [-3, -1, 2],
        [-2, 1, 2]
    ]
    b = [8, -11, -3]

    // Resolver el sistema de ecuaciones utilizando eliminación gaussiana
    solution = gaussianElimination(A, b)
    print("Las soluciones son: " + solution)


## Código en Java.

public class Gaussiana {
    public static void main(String[] args) {
        //paso 1 declarar matriz a resolver
        double[][] matriz = {
            {-1, 4, 2,11},
            {3, -1, 2,5},
            {2, 3, 2,12}
        };
        /*
        x=1
        y=2
        z=2
        */
        //paso 2 declarar un vector de la solucion
        double[] solucion = resolverSistema(matriz);
        //mostrar la solución
        System.out.println("Solución:");
        for (int i = 0; i < solucion.length; i++) {
            System.out.println("x[" + i + "] = " + solucion[i]);
        }
    }

    //metodo para resolver la matriz que retorna un vevtor de tipo double que reciba la matriz
    public static double[] resolverSistema(double[][] matriz) {
        //declaro una variable donde guarde la longitud de la matriz
        int n = matriz.length;
        //declaro un vector del tamaño de la solucion
        double[] solucion = new double[n];
        for (int i = 0; i < n; i++) {
            // Hacer los elementos debajo de la diagonal i-ésima igual a cero
            for (int j = i + 1; j < n; j++) {
                double factor = matriz[j][i] / matriz[i][i];
                for (int k = i; k < n + 1; k++) {
                    matriz[j][k] -= factor * matriz[i][k];
                }
            }
        }
        // Sustitución hacia atrás
        for (int i = n - 1; i >= 0; i--) {
            solucion[i] = matriz[i][n] / matriz[i][i];
            for (int j = i - 1; j >= 0; j--) {
                matriz[j][n] -= matriz[j][i] * solucion[i];
            }
        }

        return solucion;
    }
}

### Salida
![Captura de pantalla (380)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/30aad72a-190a-40b5-b2bb-2829909e8409)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema3/Eliminaci%C3%B3n%20Gaussiana)
********************************************************************************************************************************************
# Gauss-Jordan.
## Definición.
El método de Gauss-Jordan es una extensión del método de eliminación gaussiana que transforma una matriz en su forma reducida por filas (forma escalonada reducida). Este método no solo convierte la matriz en una forma triangular superior, sino que también elimina todos los coeficientes por debajo y por encima de los pivotes, resultando en una matriz identidad en el lado izquierdo de la matriz aumentada.
## Algoritmo.
1. Definir la matriz de coeficientes ( A ) y el vector de términos independientes ( b ).
2. Construir la matriz aumentada ([A | b]).
3. Aplicar las operaciones de fila para transformar la matriz aumentada en la forma ([I | x]), donde ( I ) es la matriz identidad.
4. El vector resultante en la columna de términos independientes es la solución ( x ).

function gaussJordan(A, b):
    n = length(b)
    // Formar la matriz aumentada
    augmentedMatrix = augmentMatrix(A, b)

    // Transformar a forma escalonada reducida
    for i from 1 to n:
        // Pivoteo parcial
        maxRow = i
        for k from i+1 to n:
            if abs(augmentedMatrix[k][i]) > abs(augmentedMatrix[maxRow][i]):
                maxRow = k
        swapRows(augmentedMatrix, i, maxRow)
        
        // Normalización
        pivot = augmentedMatrix[i][i]
        for k from i to n+1:
            augmentedMatrix[i][k] /= pivot

        // Eliminación
        for j from 1 to n:
            if j != i:
                factor = augmentedMatrix[j][i]
                for k from i to n+1:
                    augmentedMatrix[j][k] -= factor * augmentedMatrix[i][k]

    // Extraer soluciones
    x = new array[n]
    for i from 1 to n:
        x[i] = augmentedMatrix[i][n+1]

    return x

function augmentMatrix(A, b):
    augmentedMatrix = new matrix[length(b)][length(b)+1]
    for i from 1 to length(b):
        for j from 1 to length(b):
            augmentedMatrix[i][j] = A[i][j]
        augmentedMatrix[i][length(b)+1] = b[i]
    return augmentedMatrix

function swapRows(matrix, row1, row2):
    temp = matrix[row1]
    matrix[row1] = matrix[row2]
    matrix[row2] = temp

function main():
    // Definir la matriz de coeficientes A y el vector de términos independientes b
    A = [
        [2, 1, -1],
        [-3, -1, 2],
        [-2, 1, 2]
    ]
    b = [8, -11, -3]

    // Resolver el sistema de ecuaciones utilizando Gauss-Jordan
    solution = gaussJordan(A, b)
    print("Las soluciones son: " + solution)


## Código en Java.

public class GaussJordan {
    public static void main(String[] args) {
        double[][] matriz = {
            {2, 1, -1, 8},
            {-3, -1, 2, -11},
            {-2, 1, 2, -3}
        };
        /*
        x1 = 2.0
        x2 = 3.0
        x3 = -1.0
        */
        double[] solucion = resolverSistema(matriz);
        
        System.out.println("Solución:");
        for (int i = 0; i < solucion.length; i++) {
            System.out.println("x[" + i + "] = " + solucion[i]);
        }
    }
    
    public static double[] resolverSistema(double[][] matriz) {
        int n = matriz.length;
        double[] solucion = new double[n];
        
        // Convertir la matriz a una forma escalonada reducida por filas (forma escalonada reducida por Gauss-Jordan)
        for (int i = 0; i < n; i++) {
            // Dividir la fila i-ésima para que el elemento diagonal sea igual a 1
            double divisor = matriz[i][i];
            for (int j = i; j < n + 1; j++) {
                matriz[i][j] /= divisor;
            }
            
            // Hacer cero los elementos por encima y por debajo del elemento diagonal
            for (int k = 0; k < n; k++) {
                if (k != i) {
                    double factor = matriz[k][i];
                    for (int j = i; j < n + 1; j++) {
                        matriz[k][j] -= factor * matriz[i][j];
                    }
                }
            }
        }
        
        // Extraer la solución del sistema de ecuaciones de la última columna
        for (int i = 0; i < n; i++) {
            solucion[i] = matriz[i][n];
        }
        
        return solucion;
    }
}

### Salida
![Captura de pantalla (382)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/5c35c2f9-46ba-44e4-babb-a33336334423)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema3/M%C3%A9todo%20de%20Gauss-Jordan)
********************************************************************************************************************************************
# Gauss-Seidel.
## Definición.
El método de Gauss-Seidel es un método iterativo utilizado para resolver sistemas de ecuaciones lineales. A diferencia de los métodos directos como la eliminación gaussiana, los métodos iterativos generan una sucesión de aproximaciones que convergen a la solución exacta. El método de Gauss-Seidel mejora cada componente de la solución secuencialmente y utiliza inmediatamente las aproximaciones más recientes disponibles.
## Algoritmo.
1. Inicializar las soluciones (x_0^{(0)}, x_1^{(0)}, ..., x_n^{(0)}) de manera arbitraria o utilizando valores aproximados.
2. Para cada ecuación (i) en el sistema, calcular (x_i^{(k+1)}) utilizando las soluciones calculadas en la iteración (k).
3. Repetir el paso 2 hasta que se satisfaga un criterio de convergencia (por ejemplo, la diferencia entre dos iteraciones consecutivas sea menor que una tolerancia predefinida).
   

function gaussSeidel(A, b, x0, epsilon, maxIter):
    n = length(b)
    x = copy(x0)

    for k from 1 to maxIter:
        x_old = copy(x)
        
        for i from 1 to n:
            sum1 = 0
            sum2 = 0
            
            for j from 1 to i-1:
                sum1 += A[i][j] * x[j]
                
            for j from i+1 to n:
                sum2 += A[i][j] * x_old[j]
            
            x[i] = (b[i] - sum1 - sum2) / A[i][i]

        // Comprobar convergencia
        norm = 0
        for i from 1 to n:
            norm += (x[i] - x_old[i])^2

        if sqrt(norm) < epsilon:
            return x

    return x

function main():
    // Definir la matriz de coeficientes A y el vector de términos independientes b
    A = [
        [4, 1, 2],
        [3, 5, 1],
        [1, 1, 3]
    ]
    b = [4, 7, 3]

    // Definir el vector inicial x0, la tolerancia epsilon y el máximo de iteraciones maxIter
    x0 = [0, 0, 0]
    epsilon = 0.0001
    maxIter = 100

    // Resolver el sistema de ecuaciones utilizando Gauss-Seidel
    solution = gaussSeidel(A, b, x0, epsilon, maxIter)
    print("Las soluciones son: " + solution)


## Código en Java.

public class GaussSeidel {
    public static void main(String[] args) {
        double[][] coeficientes = {
            {4, -1, 0, 0},
            {-1, 4, -1, 10},
            {0, -1, 4, 10}
        };
        /*
            x1 = 0.8928489685058594
            x2 = 3.5714244842529297
            x3 = 3.3928561210632324
        */
        
        
        double[] valoresIniciales = {0, 0, 0}; // Valores iniciales de las incógnitas
        double tolerancia = 0.0001; // Tolerancia para el criterio de convergencia
        int iteracionesMaximas = 1000; // Número máximo de iteraciones
        
        double[] solucion = gaussSeidel(coeficientes, valoresIniciales, tolerancia, iteracionesMaximas);
        
        if (solucion != null) {
            System.out.println("Solución:");
            for (int i = 0; i < solucion.length; i++) {
                System.out.println("x[" + i + "] = " + solucion[i]);
            }
        } else {
            System.out.println("El método no converge.");
        }
    }
    
    public static double[] gaussSeidel(double[][] coeficientes, double[] valoresIniciales, double tolerancia, int iteracionesMaximas) {
        int n = valoresIniciales.length;
        double[] solucion = new double[n];
        double[] solucionAnterior = new double[n];
        int iteraciones = 0;
        double error = tolerancia + 1;
        
        // Inicializar la solución con los valores iniciales
        System.arraycopy(valoresIniciales, 0, solucion, 0, n);
        
        // Iterar hasta que se alcance la tolerancia o el número máximo de iteraciones
        while (error > tolerancia && iteraciones < iteracionesMaximas) {
            // Copiar la solución anterior
            System.arraycopy(solucion, 0, solucionAnterior, 0, n);
            
            // Calcular la nueva solución
            for (int i = 0; i < n; i++) {
                double suma = 0;
                for (int j = 0; j < n; j++) {
                    if (j != i) {
                        suma += coeficientes[i][j] * solucion[j];
                    }
                }
                solucion[i] = (coeficientes[i][n] - suma) / coeficientes[i][i];
            }
            
            // Calcular el error
            error = 0;
            for (int i = 0; i < n; i++) {
                error += Math.abs(solucion[i] - solucionAnterior[i]);
            }
            
            iteraciones++;
        }
        
        // Verificar la convergencia
        if (error <= tolerancia) {
            return solucion;
        } else {
            return null; // No converge
        }
    }
}

### Salida
![Captura de pantalla (383)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/fa63c45a-a050-4428-8b8b-f8238243a155)
## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema3/M%C3%A9todo%20de%20Gauss-Seidel)

********************************************************************************************************************************************
# Jacobi.
## Definición.
El método de Jacobi es un método iterativo utilizado para resolver sistemas de ecuaciones lineales. En este método, cada componente del vector solución se calcula utilizando únicamente los valores de la iteración anterior. A diferencia del método de Gauss-Seidel, el método de Jacobi no usa las aproximaciones más recientes dentro de la misma iteración.
## Algoritmo.
1.-Inicialización: Comienza con una estimación inicial de las soluciones del sistema de ecuaciones lineales 𝐴𝑥=𝑏. Puedes empezar con un vector 𝑥^(0).
2.-Iteraciones: Para cada iteración 𝑘.
3.-Criterio de parada: Repite el paso 2 hasta que se cumpla algún criterio de parada. Un criterio común es que la diferencia entre dos iteraciones consecutivas sea menor que una cierta tolerancia predefinida, o hasta que se alcance un número máximo de iteraciones.
4.-Salida: El vector 𝑥^(𝑘)será la aproximación de la solución del sistema de ecuaciones lineales.

function jacobi(A, b, x0, epsilon, maxIter):
    n = length(b)
    x = copy(x0)
    x_new = new array[n]

    for k from 1 to maxIter:
        for i from 1 to n:
            sum = 0
            
            for j from 1 to n:
                if j != i:
                    sum += A[i][j] * x[j]
            
            x_new[i] = (b[i] - sum) / A[i][i]

        // Comprobar convergencia
        norm = 0
        for i from 1 to n:
            norm += (x_new[i] - x[i])^2

        if sqrt(norm) < epsilon:
            return x_new

        x = copy(x_new)

    return x_new

function main():
    // Definir la matriz de coeficientes A y el vector de términos independientes b
    A = [
        [4, 1, 2],
        [3, 5, 1],
        [1, 1, 3]
    ]
    b = [4, 7, 3]

    // Definir el vector inicial x0, la tolerancia epsilon y el máximo de iteraciones maxIter
    x0 = [0, 0, 0]
    epsilon = 0.0001
    maxIter = 100

    // Resolver el sistema de ecuaciones utilizando Jacobi
    solution = jacobi(A, b, x0, epsilon, maxIter)
    print("Las soluciones son: " + solution)


## Código en Java.

public class Jacobi {
    public static void main(String[] args) {
        double[][] coeficientes = {
            {10,1,2,3},
            {4,6,-1,9},
            {-2,3,8,51}
        };
        /*
        X1 = -1 
        X2 = 3
        X3 = 5
        */
        double[] valoresIniciales = {0, 0, 0}; // Valores iniciales de las incógnitas
        double tolerancia = 0.0001; // Tolerancia para el criterio de convergencia
        int iteracionesMaximas = 1000; // Número máximo de iteraciones
        
        double[] solucion = jacobi(coeficientes, valoresIniciales, tolerancia, iteracionesMaximas);
        
        if (solucion != null) {
            System.out.println("Solución:");
            for (int i = 0; i < solucion.length; i++) {
                System.out.println("x[" + i + "] = " + solucion[i]);
            }
        } else {
            System.out.println("El método no converge.");
        }
    }
    
    public static double[] jacobi(double[][] coeficientes, double[] valoresIniciales, double tolerancia, int iteracionesMaximas) {
        int n = valoresIniciales.length;
        double[] solucion = new double[n];
        double[] solucionAnterior = new double[n];
        int iteraciones = 0;
        double error = tolerancia + 1;
        
        // Inicializar la solución con los valores iniciales
        System.arraycopy(valoresIniciales, 0, solucion, 0, n);
        
        // Iterar hasta que se alcance la tolerancia o el número máximo de iteraciones
        while (error > tolerancia && iteraciones < iteracionesMaximas) {
            // Copiar la solución anterior
            System.arraycopy(solucion, 0, solucionAnterior, 0, n);
            
            // Calcular la nueva solución
            for (int i = 0; i < n; i++) {
                double suma = 0;
                for (int j = 0; j < n; j++) {
                    if (j != i) {
                        suma += coeficientes[i][j] * solucionAnterior[j];
                    }
                }
                solucion[i] = (coeficientes[i][n] - suma) / coeficientes[i][i];
            }
            
            // Calcular el error
            error = 0;
            for (int i = 0; i < n; i++) {
                error += Math.abs(solucion[i] - solucionAnterior[i]);
            }
            
            iteraciones++;
        }
        
        // Verificar la convergencia
        if (error <= tolerancia) {
            return solucion;
        } else {
            return null; // No converge
        }
    }
}

### Salida
![Captura de pantalla (384)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/e916d544-d48f-4e5b-a3bb-603dde7007d1)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema3/M%C3%A9todo%20de%20Jacobi)
********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 4: Diferenciación e Integración Numérica
Aquí se cubren métodos para la diferenciación e integración de funciones. Se incluyen los métodos de Simpson 1/3, Simpson 3/8 y el método del trapecio.

# Simpson 1/3.
## Definición.
La regla de Simpson 1/3 es una técnica de integración numérica utilizada para aproximar el valor de una integral definida. Este método utiliza una interpolación cuadrática para conectar tres puntos equidistantes en el intervalo de integración y calcula el área bajo la curva utilizando la fórmula de Simpson.
## Algoritmo.
1. f(x) que se desea integrar.
2. Especificar el intervalo de integración,[a,b].
3. Dividir el intervalo [a,b] en n subintervalos de igual tamaño, donde n es un número par.
4. Calcular el ancho de cada subintervalo, h=(b−a)/2.
5. Calcular los valores de la función f(x) en los extremos de los subintervalos: f(a),f(a+h),f(a+2h),…,f(b).
6. Calcular los valores de la función f(x) en los puntos medios de los subintervalos: f(a+((h)/2)), f(a+((3h)/2)), ... , f(b+((h)/2)).
7. Aplicar la fórmula de Simpson para calcular la aproximación de la integral.
8. Devolver el valor calculado como la aproximación de la integral.
   

function simpson13(f, a, b, n):
    h = (b - a) / n
    integral = f(a) + f(b) // Sumar los extremos

    for i from 1 to n-1 step 2:
        x0 = a + i * h
        x1 = x0 + h
        x2 = x1 + h
        integral += 4 * f(x1) + 2 * f(x2) // Aplicar la fórmula de Simpson 1/3

    integral *= h / 3 // Multiplicar por el ancho del intervalo y dividir por 3

    return integral

function main():
    // Definir la función f(x), los límites de integración a y b, y el número de intervalos n
    function f(x):
        return x^2

    a = 0
    b = 2
    n = 4

    // Calcular la aproximación de la integral utilizando Simpson 1/3
    result = simpson13(f, a, b, n)
    print("El resultado de la integración es: " + result)


## Código en Java.

import java.util.function.Function;
public class Simpson13_ {
     // Método para calcular la aproximación de la integral definida utilizando la Regla de Simpson de 1/3
     public static double reglaSimpson(double a, double b, int n, Function<Double, Double> f) {
        double h = (b - a) / n; // Calcula el ancho de cada subintervalo
        double suma = f.apply(a) + f.apply(b); // Suma los valores en los extremos

        // Suma los valores en los puntos internos, alternando entre multiplicaciones por 4 y 2
        for (int i = 1; i < n; i++) {
            double x = a + i * h;
            if (i % 2 == 0) {
                suma += 2 * f.apply(x);
            } else {
                suma += 4 * f.apply(x);
            }
        }

        return (h / 3) * suma;
    }

    public static void main(String[] args) {
        // Definir los límites de integración y el número de subintervalos
        double a = 0; // Límite inferior de integración
        double b = 0.8; // Límite superior de integración
        int n = 2; // Número de subintervalos

        // Definir la función f(x) como una expresión lambda
        Function<Double, Double> funcion = x -> 0.2 + (25*x) - (200*Math.pow(x, 2)) + (675*Math.pow(x, 3)) - (900*Math.pow(x, 4)) + (400*Math.pow(x, 5));

        // Calcular la integral definida utilizando la Regla de Simpson de 1/3
        double resultado = reglaSimpson(a, b, n, funcion);
        System.out.println("El resultado de la integral definida es: " + resultado);
    }
}

### Salida
![Captura de pantalla (385)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/b08d9fc5-924d-49c1-b0e5-e2cfc72f3a42)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema4/MetodoReglaSimpson1_3)
********************************************************************************************************************************************
# Simpson 3/8.
## Definición.
La regla de Simpson 3/8 es una técnica de integración numérica utilizada para aproximar el valor de una integral definida. Este método utiliza una interpolación cúbica para conectar cuatro puntos equidistantes en el intervalo de integración y calcula el área bajo la curva utilizando la fórmula de Simpson 3/8.
## Algoritmo.
1 Definir la función f(x).
2. Lea el límite inferior de integración, el límite superior de integración y número de subintervalo.
3. Cálculos: tamaño del paso = (límite superior - límite inferior)/número de subintervalo.
4. Establecer: valor de integración = f(límite inferior) + f(límite superior).
5. Establecer: i = 1.
6. Si i > número de subintervalo, entonces vaya a.
7. Calcular: k = límite inferior + i * h.
8. Si mod 3 = 0 entonces Valor de integración = Valor de integración + 2* f(k) De lo contrario Valor de integración = Valor de integración + 3 * f(k) Terminara si.
9. Incremente i en 1, es decir, i = i+1 y vaya al paso 7.
10. Calcule: Valor de integración = Valor de integración * tamaño de paso*3/8.
11. Mostrar el valor de integración como respuesta requerida.
12. Detener.

function simpson38(f, a, b, n):
    h = (b - a) / n
    integral = f(a) + f(b) // Sumar los extremos

    for i from 1 to n-1 step 3:
        x0 = a + i * h
        x1 = x0 + h
        x2 = x1 + h
        x3 = x2 + h
        integral += 3 * (f(x0) + 3 * f(x1) + 3 * f(x2) + f(x3)) // Aplicar la fórmula de Simpson 3/8

    integral *= 3 * h / 8 // Multiplicar por el ancho del intervalo y dividir por 8

    return integral

function main():
    // Definir la función f(x), los límites de integración a y b, y el número de intervalos n
    function f(x):
        return x^2

    a = 0
    b = 2
    n = 6

    // Calcular la aproximación de la integral utilizando Simpson 3/8
    result = simpson38(f, a, b, n)
    print("El resultado de la integración es: " + result)


## Código en Java.

import java.util.function.Function;
public class Simpson38_ {
// Función para calcular la integral utilizando la regla de Simpson 3/8
public static double simpson38(Function<Double, Double> f, double a, double b, int n) {
    double h = (b - a) / n;
    double suma = f.apply(a) + f.apply(b);
    
    for (int i = 1; i < n; i++) {
        double x = a + i * h;
        if (i % 3 == 0) {
            suma += 2 * f.apply(x);
        } else {
            suma += 3 * f.apply(x);
        }
    }
    
    return (3 * h / 8) * suma;
}

// Ejemplo de uso
public static void main(String[] args) {
    // Definir la función que queremos integrar
    Function<Double, Double> funcion = x -> 0.2 + (25*x) - (200*Math.pow(x, 2)) + (675*Math.pow(x, 3)) - (900*Math.pow(x, 4)) + (400*Math.pow(x, 5));

    // Definir los límites de integración
    double a = 0; // Límite inferior
    double b = 0.8; // Límite superior

    // Definir el número de subdivisiones (debe ser múltiplo de 3)
    int n = 3;

    // Calcular la aproximación de la integral
    double integral = simpson38(funcion, a, b, n);

    // Imprimir el resultado
    System.out.println("Aproximación de la integral: " + integral);
}
}

### Salida
![Captura de pantalla (386)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/cc5cdae2-1310-4aa2-9e61-38e6c7ff94ee)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema4/MetodoReglaSimpson3_8)
********************************************************************************************************************************************
# Trapecio.
## Definición.
El método del trapecio es una técnica de integración numérica utilizada para aproximar el valor de una integral definida. La idea detrás del método del trapecio es aproximar el área bajo una curva mediante un conjunto de trapecios cuyas bases son segmentos de la curva y cuyas alturas son la distancia entre los puntos de la partición. En esencia, se aproxima el área bajo la curva como la suma de las áreas de los trapecios.
## Algoritmo.
1. Definir el intervalo de integración [a, b] y el número de subintervalos n en los que se dividirá el intervalo.
2. Calcular el ancho de cada subintervalo: h = (b - a) / n
3. Evaluar la función en los puntos extremos del intervalo (a y b) y en los puntos intermedios (xi = a + i*h, donde i = 1, 2, ..., n-1).
4. Calcular la aproximación de la integral definida utilizando la fórmula del trapecio: Integral aproximada = (h/2) * (f(a) + 2*[f(x1) + f(x2) + ... + f(xn-1)] + f(b)) Donde f(a), f(b) y f(xi) son los valores de la función evaluada en los puntos correspondientes.
5. Cuantos más subintervalos se tomen (es decir, mayor sea n), más precisa será la aproximación de la integral.

Función Trapecio(f, a, b, n):
    h = (b - a) / n
    suma = 0.5 * (f(a) + f(b)) // Sumamos el valor de f(a) y f(b) al resultado
    Para i desde 1 hasta n-1:
        xi = a + i * h // Calculamos los puntos de partición
        suma = suma + f(xi) // Sumamos el valor de f(xi) al resultado
    resultado = h * suma // Multiplicamos por el ancho de los trapecios
    Devolver resultado

## Código en Java.

import java.util.function.Function;
public class Trapecio {
// Método para calcular la aproximación de la integral definida utilizando el método del trapecio
public static double metodoTrapecio(double a, double b, int n, Function<Double, Double> f) {
    double h = (b - a) / n; // Calcula el ancho de cada subintervalo
    double suma = 0.5 * (f.apply(a) + f.apply(b)); // Suma los valores en los extremos
    // Suma los valores en los puntos internos
    for (int i = 1; i < n; i++) {
        double x = a + i * h;
        suma += f.apply(x);
    }
    return h * suma;
}

public static void main(String[] args) {
    double a = 1.3; // Límite inferior de integración
    double b = 1.8; // Límite superior de integración
    int n = 1; // Número de subintervalos
    // Definir la función f(x) como una expresión lambda
    Function<Double, Double> funcion = x ->  Math.pow(x, 3) - (6*Math.pow(x, 2)) + (11*x) - 6;
    // Calcular la integral definida utilizando el método del trapecio
    double resultado = metodoTrapecio(a, b, n, funcion);
    System.out.println("El resultado de la integral definida es: " + resultado);
}
}

### Salida
![Captura de pantalla (387)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/0af931b1-bfca-43c6-932c-f96704890ab8)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema4/MetodoTrapecio)

********************************************************************************************************************************************
# Tema 5: Interpolación y Ajuste de Funciones
En este tema se estudian técnicas de interpolación y ajuste de funciones, como la interpolación cuadrática, lineal, de Lagrange y de Newton.
# Interpolación Cuadrática.
## Definición.
para mejorar la estimación consiste en introducir alguna curvatura a la línea que une los puntos. Si se tienen tres puntos como datos, éstos pueden ajustarse en un polinomio de segundo grado (también conocido como polinomio cuadrático o parábola).
## Algoritmo.
1. Definir los puntos conocidos.
2. Formar el Sistema de Ecuaciones.
3. Resolver el Sistema de Ecuaciones.
4. Formar el Polinomio Interpolante.

Algoritmo InterpolacionCuadratica(x0, y0, x1, y1, x2, y2, x)
    Entrada:
        x0, y0: coordenadas del primer punto conocido
        x1, y1: coordenadas del segundo punto conocido
        x2, y2: coordenadas del tercer punto conocido
        x: valor de x para el cual queremos estimar el valor de y
    Salida:
        y: valor interpolado de y

    // Paso 1: Calcular los coeficientes a, b y c
    a = ((y2 - y0) / ((x2 - x0) * (x2 - x1)) - (y1 - y0) / ((x1 - x0) * (x2 - x1))) / (x2 - x0)
    b = (y1 - y0) / (x1 - x0) - a * (x1 + x0)
    c = y0 - a * x0^2 - b * x0
    
    // Paso 2: Calcular el valor interpolado de y
    y = a * x^2 + b * x + c
    
    Retornar y
Fin Algoritmo

## Código en Java.

public class Interpolacion_cuadratica {

    public static void main(String[] args) {
         // Datos de ejemplo
        double x0 = 1.0;
        double x1 = 2.0;
        double x2 = 3.0;
        double y0 = 3.0;
        double y1 = 5.0;
        double y2 = 9.0;
        double x = 2.5;
        // Realizar interpolación cuadrática
        double resultado = interpolacionCuadratica(x0, x1, x2, y0, y1, y2, x);
        System.out.println("El resultado de la interpolación cuadrática en x = " + x + " es: " + resultado);
    }
    
    public static double interpolacionCuadratica(double x0, double x1, double x2, double y0, double y1, double y2, double x) {
        double L0 = ((x - x1) * (x - x2)) / ((x0 - x1) * (x0 - x2));
        double L1 = ((x - x0) * (x - x2)) / ((x1 - x0) * (x1 - x2));
        double L2 = ((x - x0) * (x - x1)) / ((x2 - x0) * (x2 - x1));

        double result = (y0 * L0) + (y1 * L1) + (y2 * L2);
        return result;
    }
}

### Salida
![331050435-913d39b9-aca9-455d-ac3e-59bd85932344](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/cb5e5c3c-6903-49c6-98e4-0916f55c8074)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema5/Interpolaci%C3%B3n_de_M%C3%ADnimos_Cuadrado)
********************************************************************************************************************************************
# Interpolación Lineal.
## Definición.
La forma más simple de interpolación consiste en unir dos puntos con una línea recta. Dicha técnica es llamada interpolación lineal. La notación f1(x) designa que éste es un polinomio de interpolación de primer grado. Observe que además de representar la pendiente de la línea que une los puntos, el término f(x1) – f(x0)/(x1 – x0) es una aproximación en diferencia dividida finita a la primer derivada
## Algoritmo.
1. Definir los puntos conocidos.
2. Calcular la Pendiente.
3. Calcular la Intersección.
4. Formar la Ecuación de la Recta.
5. Calcular el Valor Interpolado.

Algoritmo InterpolacionLineal(x0, y0, x1, y1, x)
    Entrada:
        x0, y0: coordenadas del primer punto conocido
        x1, y1: coordenadas del segundo punto conocido
        x: valor de x para el cual queremos estimar el valor de y
    Salida:
        y: valor estimado de y

    // Paso 1: Calcular la pendiente (m)
    m <- (y1 - y0) / (x1 - x0)
    
    // Paso 2: Calcular el valor interpolado de y
    y <- y0 + m * (x - x0)
    
    Retornar y
Fin Algoritmo

## Código en Java.

public class InterpolacionLineal {

    // Método para realizar la interpolación lineal
    public static double interpolacionLineal(double x0, double y0, double x1, double y1, double x) {
        // Calcular la pendiente (m)
        double m = (y1 - y0) / (x1 - x0);
        // Calcular el valor interpolado de y
        return y0 + m * (x - x0);
    }

    public static void main(String[] args) {
        // Puntos conocidos
        double x0 = 1.0, y0 = 2.0;
        double x1 = 3.0, y1 = 3.0;
        // Valor de x para el cual queremos estimar y
        double x = 2.0;
        
        // Calcular el valor interpolado de y
        double y = interpolacionLineal(x0, y0, x1, y1, x);
        
        // Imprimir el resultado
        System.out.println("El valor interpolado de y para x=" + x + " es " + y);
    }
}

### Salida
![331012519-d3901a4a-668d-4317-9815-c74ab3e87653](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/5a7b08ac-ccb0-48d7-afcf-e10a3660fdfb)

## Ejercicios
[Enlace de ejercicios](https://github.com/rubivj13/MetodosNumericos_Tema6/tree/master/Tema5/Interpolaci%C3%B3n_Lineal)
********************************************************************************************************************************************
# Lagrange.
## Definición.
La interpolación de Lagrange es un método de interpolación polinómica que utiliza un polinomio de grado n-1 para aproximar una funciónf(x) a partir de n puntos conocidos.
El polinomio de Lagrange P(x) se construye como una combinación lineal de los polinomios base de Lagrange Li(x).
## Algoritmo.
1. Obtener los puntos (x0, y0), (x1, y1), ..., (xn, yn).
2. Calcular los polinomios de Lagrange Li(x) para cada punto (xi, yi).
3. Construir el polinomio interpolante P(x) como la suma ponderada de los polinomios de Lagrange.
4. Evaluar el polinomio interpolante P(x) en el punto deseado x_eval.

function lagrangeInterpolation(x_vals, y_vals, x):
    n = length(x_vals)
    P = 0

    for i from 0 to n-1:
        Li = 1
        for j from 0 to n-1:
            if j != i:
                Li *= (x - x_vals[j]) / (x_vals[i] - x_vals[j])
        P += y_vals[i] * Li

    return P

function main():
    // Definir los puntos conocidos
    x_vals = [0, 1, 2]
    y_vals = [1, 3, 2]

    // Definir el punto donde se quiere interpolar
    x = 1.5

    // Calcular la interpolación de Lagrange
    resultado = lagrangeInterpolation(x_vals, y_vals, x)
    print("El valor interpolado en x =", x, "es", resultado)


## Código en Java.

import java.util.ArrayList;
import java.util.List;
public class Lagrange {
    // Método para calcular el polinomio de Lagrange
    public static double lagrange(List<Double> x, List<Double> y, double xi) {
        double result = 0;

        for (int i = 0; i < x.size(); i++) {
            double term = y.get(i);
            for (int j = 0; j < x.size(); j++) {
                if (j != i) {
                    term = term * (xi - x.get(j)) / (x.get(i) - x.get(j));
                }
            }
            result += term;
        }

        return result;
    }

    public static void main(String[] args) {
        // Puntos conocidos
        List<Double> x = new ArrayList<>();
        List<Double> y = new ArrayList<>();

        // Agregar puntos conocidos (x, y)
        x.add(1.0);
        x.add(2.0);
        x.add(3.0);
        y.add(2.0);
        y.add(3.0);
        y.add(5.0);

        // Punto donde queremos aproximar
        double xi = 2.5;

        // Calcular el valor aproximado usando el método de Lagrange
        double result = lagrange(x, y, xi);
        System.out.println("El valor aproximado en x = " + xi + " es: " + result);
    }
}

### Salida
